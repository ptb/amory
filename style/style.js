/*! @copyright Ryan Tsao | @license MIT | @link github.com/styletron/styletron */import{hyphenateStyleName,prefix}from"./prefixer.js";class Cache{constructor(e,t){this.cache={},this.idGenerator=e,this.onNewValue=t}addValue(e,t){const s=this.cache[e];if(s)return s;const n=this.idGenerator.next();return this.cache[e]=n,this.onNewValue(this,n,t),n}}class MultiCache{constructor(e,t,s){this.caches={},this.idGenerator=e,this.onNewCache=t,this.onNewValue=s}getCache(e){if(!this.caches[e]){const t=new Cache(this.idGenerator,this.onNewValue);t.key=e,this.caches[e]=t,this.onNewCache(e,t)}return this.caches[e]}}const atomicSelector=(e,t)=>{let s=`.${e}`;return t&&(s+=t),s},canUseDOM=Boolean("undefined"!=typeof window&&window.document&&window.document.createElement),declarationsToBlock=e=>{let t="";for(const s in e){const n=e[s];"string"!=typeof n&&"number"!=typeof n||(t+=`${hyphenateStyleName(s)}:${n};`)}return t.slice(0,-1)},fontFaceBlockToRule=(e,t)=>`@font-face{font-family:${e};${t}}`,keyframesBlockToRule=(e,t)=>`@keyframes ${e}{${t}}`,keyframesToBlock=e=>{let t="";for(const s in e)t+=`${s}{${declarationsToBlock(e[s])}}`;return t},styleBlockToRule=(e,t)=>`${e}{${t}}`;class IDGenerator{constructor(e=""){this.count=0,this.msb=1295,this.offset=374,this.power=2,this.prefix=e}increment(){const e=this.count+this.offset;return e===this.msb&&(this.offset+=9*(this.msb+1),this.msb=Math.pow(36,++this.power)-1),this.count+=1,e}next(){const e=this.increment().toString(36);return this.prefix?`${this.prefix}${e}`:e}}const prefix$1=(e,t,s,n)=>{const r=e.getCache(s);let a="";for(const c in t){const i=t[c];if("object"!=typeof i){const e=`${hyphenateStyleName(c)}:${i}`,t=`${n}${e}`,s=r.cache[t];if(void 0!==s){a+=` ${s}`;continue}{let s="";const o=prefix({[c]:i});for(const t in o){const n=o[t],r=typeof n;if("string"===r||"number"===r){const r=`${hyphenateStyleName(t)}:${n}`;r!==e&&(s+=`${r};`)}else if(Array.isArray(n)){const r=hyphenateStyleName(t);for(let t=0;t<n.length;t++){const a=`${r}:${n[t]}`;a!==e&&(s+=`${a}`)}}}s+=e,a+=` ${r.addValue(t,{block:s,pseudo:n})}`}}else":"===c[0]?a+=` ${prefix$1(e,i,s,n+c)}`:"@media"===c.substring(0,6)&&(a+=` ${prefix$1(e,i,c.substr(7),n)}`)}return a.slice(1)},FONT_FACE_HYDRATOR=/@font-face\{font-family:([^;]+);([^}]*)\}/g,KEYFRAMES_HYDRATOR=/@keyframes ([^{]+)\{((?:[^{]+\{[^}]*\})*)\}/g,STYLES_HYDRATOR=/\.([^{:]+)(:[^{]+)?{(?:[^}]*;)?([^}]*?)}/g,attrsToString=e=>Object.entries(e).reduce((e,[t,s])=>e+s===!0?` ${t}`:` ${t}="${s}"`,""),generateHtmlString=(e,t)=>Object.values(e).reduce((e,s)=>{const{class:n,...r}=s.attrs,a={class:n?`${t} ${n}`:t,...r};return`${e}<style${attrsToString(a)}>${s.css}</style>`},""),hydrate=(e,t,s)=>{let n;for(;n=t.exec(s);){const[,t,s]=n;e.cache[s]=t,e.idGenerator.increment()}},hydrateStyles=(e,t,s)=>{let n;for(;n=t.exec(s);){const[,t,s,r]=n,a=s?`${s}${r}`:r;e.cache[a]=t,e.idGenerator.increment()}},sheetify=e=>Object.keys(e).reduce((t,s)=>{const n=s?{media:s}:{};return t.concat({attrs:n,css:e[s]})},[]),stringify=e=>Object.entries(e).reduce((e,[t,s])=>`${e}${t?`@media ${t}{${s}}`:s}`,"");class Engine{constructor(e={}){this.idGenerator=new IDGenerator(e.prefix),this.styleElements={},this.fontFaceRules="",this.keyframesRules="",this.styleRules={"":""};const t=(e,t,s)=>{const{block:n,pseudo:r}=s,a=styleBlockToRule(atomicSelector(t,r),n);if(canUseDOM){const t=this.styleElements[e.key].sheet;t.insertRule(a,t.cssRules.length)}else this.styleRules[e.key]+=a};this.styleCache=this.createStyleCache(t),this.fontFaceCache=this.createFontFaceCache(),this.keyframesCache=this.createKeyframesCache(),this.rehydrate(t)}createFontFaceCache(){return new Cache(this.idGenerator,(e,t,s)=>{const n=fontFaceBlockToRule(t,declarationsToBlock(s));if(canUseDOM){this.styleCache.getCache("");const e=this.styleElements[""].sheet;e.insertRule(n,e.cssRules.length)}else this.fontFaceRules+=n})}createKeyframesCache(){return new Cache(this.idGenerator,(e,t,s)=>{const n=keyframesBlockToRule(t,keyframesToBlock(s));if(canUseDOM){this.styleCache.getCache("");const e=this.styleElements[""].sheet;e.insertRule(n,e.cssRules.length)}else this.keyframesRule+=n})}createStyleCache(e){return new MultiCache(this.idGenerator,e=>{if(canUseDOM){const t=document.createElement("style");t.media=e,document.head.appendChild(t),this.styleElements[e]=t}else this.styleRules[e]=""},e)}getCss(){return this.fontFaceRules+stringify(this.styleRules)+this.keyframesRules}getStylesheets(){return[...this.fontFaceRules.length?[{attrs:{"data-hydrate":"font-face"},css:this.fontFaceRules}]:[],...sheetify(this.styleRules),...this.keyframesRules.length?[{attrs:{"data-hydrate":"keyframes"},css:this.keyframesRules}]:[]]}getStylesheetsHtml(e="hydrate"){return generateHtmlString(this.getStylesheets(),e)}rehydrate(e){canUseDOM&&Object.values(document.getElementsByClassName("hydrate")).forEach(t=>{const s=new Cache(this.idGenerator,e),n=t.media?t.media:"";switch(t.dataset.hydrate){case"font-face":hydrate(this.fontFaceCache,FONT_FACE_HYDRATOR,t.textContent);break;case"keyframes":hydrate(this.keyframesCache,KEYFRAMES_HYDRATOR,t.textContent);break;default:s.key=n,hydrateStyles(s,STYLES_HYDRATOR,t.textContent),this.styleCache.caches[n]=s,this.styleElements[n]=t}})}renderFontFace(e){const t=canUseDOM?declarationsToBlock(e):JSON.stringify(e);return this.fontFaceCache.addValue(t,e)}renderKeyframes(e){const t=canUseDOM?keyframesToBlock(e):JSON.stringify(e);return this.keyframesCache.addValue(t,e)}renderStyle(e){return prefix$1(this.styleCache,e,"","")}}const instance=(()=>new Engine)(),renderDeclarativeRules=(e,t)=>Object.entries(e).reduce((e,[s,n])=>("animationName"===s&&"string"!=typeof n&&(e.animationName=t.renderKeyframes(n)),"fontFamily"===s&&"string"!=typeof n&&(e.fontFamily=t.renderFontFace(n)),"object"==typeof n&&null!==n&&renderDeclarativeRules(n,t),e),e),css=(e,t=instance)=>t.renderStyle(renderDeclarativeRules(e,t));export{css,css as driver,instance};
