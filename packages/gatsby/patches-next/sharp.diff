--- node_modules/gatsby-plugin-sharp/index.js
+++ node_modules/gatsby-plugin-sharp/index.js
@@ -4,6 +4,25 @@
 
 var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
 
+function mkdirp (p, made) {
+  var mode = parseInt('0777', 8) & (~process.umask());
+  if (!made) made = null;
+  p = path.resolve(p);
+  try {
+    fs.mkdirSync(p, mode);
+    made = made || p;
+  }
+  catch (err0) {
+    switch (err0.code) {
+      case 'ENOENT' :
+        made = mkdirp(path.dirname(p), made);
+        mkdirp(p, made);
+        break;
+    }
+  }
+  return made;
+};
+
 const sharp = require(`sharp`);
 
 const crypto = require(`crypto`);
@@ -283,10 +302,11 @@
   const sortedArgs = _.sortBy(filteredArgs, arg => arg[0] === `width`);
 
   const fileExtension = options.toFormat ? options.toFormat : file.extension;
-  const argsDigest = crypto.createHash(`md5`).update(JSON.stringify(sortedArgs)).digest(`hex`);
-  const argsDigestShort = argsDigest.substr(argsDigest.length - 5);
-  const imgSrc = `/${file.name}-${file.internal.contentDigest}-${argsDigestShort}.${fileExtension}`;
-  const filePath = path.join(process.cwd(), `public`, `static`, imgSrc); // Create function to call when the image is finished.
+  const argsDigest = crypto.createHash(`sha1`).update(JSON.stringify(sortedArgs)).digest(`hex`);
+  const argsDigestShort = argsDigest.slice(0,6);
+  const imgSrc = `/${file.internal.contentDigest.slice(0,6)}-${argsDigestShort}.${fileExtension}`;
+  mkdirp(path.join(process.cwd(), `public`, `img`, file.relativeDirectory ? file.relativeDirectory : ".", file.name))
+  const filePath = path.join(process.cwd(), `public`, `img`, file.relativeDirectory ? file.relativeDirectory : ".", file.name, imgSrc); // Create function to call when the image is finished.
 
   let outsideResolve, outsideReject;
   const finishedPromise = new Promise((resolve, reject) => {
@@ -325,7 +345,7 @@
   };
   queueJob(job, reporter); // Prefix the image src.
 
-  const prefixedSrc = options.pathPrefix + `/static` + imgSrc;
+  const prefixedSrc = options.pathPrefix + `/img/` + (file.relativeDirectory ? `${file.relativeDirectory}/` : "") + file.name + imgSrc;
   return {
     src: prefixedSrc,
     absolutePath: filePath,
@@ -484,9 +504,7 @@
     sizes.push(options.maxWidth / 4);
     sizes.push(options.maxWidth / 2);
     sizes.push(options.maxWidth);
-    sizes.push(options.maxWidth * 1.5);
     sizes.push(options.maxWidth * 2);
-    sizes.push(options.maxWidth * 3);
     const filteredSizes = sizes.filter(size => size < width); // Add the original image to ensure the largest image possible
     // is available for small images. Also so we can link to
     // the original image.
@@ -533,7 +551,7 @@
 
     const fallbackSrc = _.minBy(images, image => Math.abs(options.maxWidth - image.width)).src;
 
-    const srcSet = images.map(image => `${image.src} ${Math.round(image.width)}w`).join(`,\n`);
+    const srcSet = images.map(image => `${image.src} ${Math.round(image.width)}w`).join(`,`);
     const originalName = file.base;
     return {
       base64: base64Image.src,
@@ -633,24 +651,14 @@
         case 0:
           resolution = `1x`;
           break;
-
         case 1:
-          resolution = `1.5x`;
-          break;
-
-        case 2:
           resolution = `2x`;
           break;
-
-        case 3:
-          resolution = `3x`;
-          break;
-
         default:
       }
 
       return `${image.src} ${resolution}`;
-    }).join(`,\n`);
+    }).join(`,`);
     const originalName = file.base;
     return {
       base64: base64Image.src,
@@ -764,7 +772,6 @@
 function encodeOptimizedSVGDataUri(svgString) {
   var uriPayload = encodeURIComponent(svgString) // encode URL-unsafe characters
   .replace(/%0A/g, ``) // remove newlines
-  .replace(/%20/g, ` `) // put spaces back in
   .replace(/%3D/g, `=`) // ditto equals signs
   .replace(/%3A/g, `:`) // ditto colons
   .replace(/%2F/g, `/`) // ditto slashes
