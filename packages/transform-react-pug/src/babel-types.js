//      
// generated by scripts/generate-babel-types.js


let t      = null;
let currentLocation      = null;
const getCurrentLocation = function ()           { return currentLocation; };
const setCurrentLocation = function (loc          )           { return currentLocation = loc; };
const setBabelTypes = function (_t        )           { return t = _t; };

const BabelTypes = {
  anyTypeAnnotation()                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.AnyTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  arrayExpression(elements                                                    )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ArrayExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  arrayPattern(elements                            , typeAnnotation       )               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ArrayPattern.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  arrayTypeAnnotation(elementType       )                      {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ArrayTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  arrowFunctionExpression(params                      , body                             , async          )                          {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ArrowFunctionExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  assignmentExpression(operator        , left      , right            )                       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.AssignmentExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  assignmentPattern(left            , right            )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.AssignmentPattern.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  awaitExpression(argument            )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.AwaitExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  binaryExpression(operator                                                                                                                                                          , left            , right            )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BinaryExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  bindExpression(object       , callee       )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BindExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  blockStatement(body                           , directives                            )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BlockStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  booleanLiteral(value         )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BooleanLiteral.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  booleanLiteralTypeAnnotation()                               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BooleanLiteralTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  booleanTypeAnnotation()                        {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BooleanTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  breakStatement(label             )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.BreakStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  callExpression(callee            , _arguments                                            )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.CallExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  catchClause(param            , body                )              {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.CatchClause.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  classBody(body                                             )            {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassBody.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  classDeclaration(id            , superClass             , body           , decorators                           )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassDeclaration.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  classExpression(id             , superClass             , body           , decorators                           )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  classImplements(id       , typeParameters       )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassImplements.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  classMethod(kind                                           , key            , params                      , body                , computed          , _static          )              {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassMethod.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  classProperty(key       , value       , typeAnnotation       , decorators       , computed          )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ClassProperty.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  conditionalExpression(test            , consequent            , alternate            )                        {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ConditionalExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  continueStatement(label             )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ContinueStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  debuggerStatement()                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DebuggerStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  declareClass(id       , typeParameters       , _extends       , body       )               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareClass.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  declareFunction(id       )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareFunction.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  declareInterface(id       , typeParameters       , _extends       , body       )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareInterface.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  declareModule(id       , body       )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareModule.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  declareModuleExports(typeAnnotation       )                       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareModuleExports.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  declareTypeAlias(id       , typeParameters       , right       )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareTypeAlias.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  declareVariable(id       )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DeclareVariable.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  decorator(expression            )            {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Decorator.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  directive(value                  )            {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Directive.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  directiveLiteral(value        )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DirectiveLiteral.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  doExpression(body                )               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DoExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  doWhileStatement(test            , body           )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.DoWhileStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  emptyStatement()                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.EmptyStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  emptyTypeAnnotation()                      {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.EmptyTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  existentialTypeParam()                       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExistentialTypeParam.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  exportAllDeclaration(source               )                       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportAllDeclaration.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  exportDefaultDeclaration(declaration                                                     )                           {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportDefaultDeclaration.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  exportDefaultSpecifier(exported            )                         {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportDefaultSpecifier.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  exportNamedDeclaration(declaration              , specifiers                                 , source                )                         {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportNamedDeclaration.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  exportNamespaceSpecifier(exported            )                           {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportNamespaceSpecifier.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  exportSpecifier(local            , exported            )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExportSpecifier.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  expressionStatement(expression            )                      {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ExpressionStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  file(program         , comments       , tokens       )       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.File.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  forAwaitStatement(left                            , right            , body           )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ForAwaitStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  forInStatement(left                            , right            , body           )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ForInStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  forOfStatement(left                            , right            , body           )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ForOfStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  forStatement(init                                   , test             , update             , body           )               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ForStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  functionDeclaration(id            , params                      , body                , generator          , async          )                      {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.FunctionDeclaration.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  functionExpression(id             , params                      , body                , generator          , async          )                     {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.FunctionExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  functionTypeAnnotation(typeParameters       , params       , rest       , returnType       )                         {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.FunctionTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  functionTypeParam(name       , typeAnnotation       )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.FunctionTypeParam.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  genericTypeAnnotation(id       , typeParameters       )                        {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.GenericTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  identifier(name        )             {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Identifier.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  ifStatement(test            , consequent           , alternate            )              {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.IfStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  import()         {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Import.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  importDeclaration(specifiers                                                                                     , source               )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ImportDeclaration.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  importDefaultSpecifier(local            )                         {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ImportDefaultSpecifier.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  importNamespaceSpecifier(local            )                           {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ImportNamespaceSpecifier.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  importSpecifier(local            , imported            )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ImportSpecifier.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  interfaceDeclaration(id       , typeParameters       , _extends       , body       )                       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.InterfaceDeclaration.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  interfaceExtends(id       , typeParameters       )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.InterfaceExtends.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  intersectionTypeAnnotation(types       )                             {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.IntersectionTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXAttribute(name                                   , value                                                      )               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXAttribute.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXClosingElement(name                                     )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXClosingElement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXElement(openingElement                   , closingElement                    , children                                                                                , selfClosing       )             {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXElement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXEmptyExpression()                     {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXEmptyExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXExpressionContainer(expression            )                         {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXExpressionContainer.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXIdentifier(name        )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXIdentifier.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXMemberExpression(object                                     , property               )                      {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXMemberExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXNamespacedName(namespace               , name               )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXNamespacedName.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXOpeningElement(name                                     , attributes                                                   , selfClosing          )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXOpeningElement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXSpreadAttribute(argument            )                     {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXSpreadAttribute.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXSpreadChild(expression            )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXSpreadChild.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  jSXText(value        )          {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.JSXText.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  labeledStatement(label            , body           )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.LabeledStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  logicalExpression(operator             , left            , right            )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.LogicalExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  memberExpression(object            , property            , computed          )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.MemberExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  metaProperty(meta        , property        )               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.MetaProperty.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  mixedTypeAnnotation()                      {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.MixedTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  newExpression(callee            , _arguments                                            )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NewExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  noop()       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Noop.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  nullLiteral()              {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NullLiteral.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  nullLiteralTypeAnnotation()                            {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NullLiteralTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  nullableTypeAnnotation(typeAnnotation       )                         {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NullableTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  numberTypeAnnotation()                       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NumberTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  numericLiteral(value        )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NumericLiteral.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  numericLiteralTypeAnnotation()                               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.NumericLiteralTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  objectExpression(properties                                                                )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  objectMethod(kind                           , key            , params       , body                , computed          )               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectMethod.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  objectPattern(properties                                         , typeAnnotation       )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectPattern.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  objectProperty(key            , value            , computed          , shorthand          , decorators                            )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectProperty.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  objectTypeAnnotation(properties       , indexers       , callProperties       )                       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  objectTypeCallProperty(value       )                         {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectTypeCallProperty.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  objectTypeIndexer(id       , key       , value       )                    {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectTypeIndexer.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  objectTypeProperty(key       , value       )                     {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ObjectTypeProperty.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  parenthesizedExpression(expression            )                          {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ParenthesizedExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  program(body                           , directives                            )          {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Program.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  qualifiedTypeIdentifier(id       , qualification       )                          {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.QualifiedTypeIdentifier.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  regExpLiteral(pattern        , flags         )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.RegExpLiteral.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  restElement(argument      , typeAnnotation       )              {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.RestElement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  restProperty(argument      )               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.RestProperty.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  returnStatement(argument             )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ReturnStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  sequenceExpression(expressions                            )                     {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SequenceExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  spreadElement(argument            )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SpreadElement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  spreadProperty(argument            )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SpreadProperty.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  stringLiteral(value        )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.StringLiteral.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  stringLiteralTypeAnnotation()                              {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.StringLiteralTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  stringTypeAnnotation()                       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.StringTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  super()        {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.Super.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  switchCase(test             , consequent                           )             {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SwitchCase.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  switchStatement(discriminant            , cases                            )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.SwitchStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  taggedTemplateExpression(tag            , quasi                 )                           {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TaggedTemplateExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  templateElement(value       , tail          )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TemplateElement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  templateLiteral(quasis                                 , expressions                            )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TemplateLiteral.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  thisExpression()                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ThisExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  thisTypeAnnotation()                     {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ThisTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  throwStatement(argument            )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.ThrowStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  tryStatement(block       , handler        , finalizer                 )               {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TryStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  tupleTypeAnnotation(types       )                      {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TupleTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  typeAlias(id       , typeParameters       , right       )            {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeAlias.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  typeAnnotation(typeAnnotation       )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  typeCastExpression(expression       , typeAnnotation       )                     {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeCastExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  typeParameter(bound       )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeParameter.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  typeParameterDeclaration(params       )                           {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeParameterDeclaration.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  typeParameterInstantiation(params       )                             {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeParameterInstantiation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  typeofTypeAnnotation(argument       )                       {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.TypeofTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  unaryExpression(operator                                                                    , argument            , prefix          )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.UnaryExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  unionTypeAnnotation(types       )                      {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.UnionTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  updateExpression(operator             , argument            , prefix          )                   {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.UpdateExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  variableDeclaration(kind                         , declarations                                    )                      {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.VariableDeclaration.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  variableDeclarator(id      , init             )                     {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.VariableDeclarator.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  voidTypeAnnotation()                     {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.VoidTypeAnnotation.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  whileStatement(test            , body                            )                 {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.WhileStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  withStatement(object       , body                            )                {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.WithStatement.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  yieldExpression(argument             , delegate          )                  {
    const args = ([].slice     ).call(arguments);
    let loc = args[args.length - 1];
    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');
    if (hasLoc) {
      args.pop();
    }
    return {...t.YieldExpression.apply(t, args), loc: hasLoc ? (loc     ) : getCurrentLocation()};
  },
  isAnyTypeAnnotation(value     , opts         )          {
    return t.isAnyTypeAnnotation.apply(t, arguments);
  },
  isArrayExpression(value     , opts         )          {
    return t.isArrayExpression.apply(t, arguments);
  },
  isArrayPattern(value     , opts         )          {
    return t.isArrayPattern.apply(t, arguments);
  },
  isArrayTypeAnnotation(value     , opts         )          {
    return t.isArrayTypeAnnotation.apply(t, arguments);
  },
  isArrowFunctionExpression(value     , opts         )          {
    return t.isArrowFunctionExpression.apply(t, arguments);
  },
  isAssignmentExpression(value     , opts         )          {
    return t.isAssignmentExpression.apply(t, arguments);
  },
  isAssignmentPattern(value     , opts         )          {
    return t.isAssignmentPattern.apply(t, arguments);
  },
  isAwaitExpression(value     , opts         )          {
    return t.isAwaitExpression.apply(t, arguments);
  },
  isBinaryExpression(value     , opts         )          {
    return t.isBinaryExpression.apply(t, arguments);
  },
  isBindExpression(value     , opts         )          {
    return t.isBindExpression.apply(t, arguments);
  },
  isBlockStatement(value     , opts         )          {
    return t.isBlockStatement.apply(t, arguments);
  },
  isBooleanLiteral(value     , opts         )          {
    return t.isBooleanLiteral.apply(t, arguments);
  },
  isBooleanLiteralTypeAnnotation(value     , opts         )          {
    return t.isBooleanLiteralTypeAnnotation.apply(t, arguments);
  },
  isBooleanTypeAnnotation(value     , opts         )          {
    return t.isBooleanTypeAnnotation.apply(t, arguments);
  },
  isBreakStatement(value     , opts         )          {
    return t.isBreakStatement.apply(t, arguments);
  },
  isCallExpression(value     , opts         )          {
    return t.isCallExpression.apply(t, arguments);
  },
  isCatchClause(value     , opts         )          {
    return t.isCatchClause.apply(t, arguments);
  },
  isClassBody(value     , opts         )          {
    return t.isClassBody.apply(t, arguments);
  },
  isClassDeclaration(value     , opts         )          {
    return t.isClassDeclaration.apply(t, arguments);
  },
  isClassExpression(value     , opts         )          {
    return t.isClassExpression.apply(t, arguments);
  },
  isClassImplements(value     , opts         )          {
    return t.isClassImplements.apply(t, arguments);
  },
  isClassMethod(value     , opts         )          {
    return t.isClassMethod.apply(t, arguments);
  },
  isClassProperty(value     , opts         )          {
    return t.isClassProperty.apply(t, arguments);
  },
  isConditionalExpression(value     , opts         )          {
    return t.isConditionalExpression.apply(t, arguments);
  },
  isContinueStatement(value     , opts         )          {
    return t.isContinueStatement.apply(t, arguments);
  },
  isDebuggerStatement(value     , opts         )          {
    return t.isDebuggerStatement.apply(t, arguments);
  },
  isDeclareClass(value     , opts         )          {
    return t.isDeclareClass.apply(t, arguments);
  },
  isDeclareFunction(value     , opts         )          {
    return t.isDeclareFunction.apply(t, arguments);
  },
  isDeclareInterface(value     , opts         )          {
    return t.isDeclareInterface.apply(t, arguments);
  },
  isDeclareModule(value     , opts         )          {
    return t.isDeclareModule.apply(t, arguments);
  },
  isDeclareModuleExports(value     , opts         )          {
    return t.isDeclareModuleExports.apply(t, arguments);
  },
  isDeclareTypeAlias(value     , opts         )          {
    return t.isDeclareTypeAlias.apply(t, arguments);
  },
  isDeclareVariable(value     , opts         )          {
    return t.isDeclareVariable.apply(t, arguments);
  },
  isDecorator(value     , opts         )          {
    return t.isDecorator.apply(t, arguments);
  },
  isDirective(value     , opts         )          {
    return t.isDirective.apply(t, arguments);
  },
  isDirectiveLiteral(value     , opts         )          {
    return t.isDirectiveLiteral.apply(t, arguments);
  },
  isDoExpression(value     , opts         )          {
    return t.isDoExpression.apply(t, arguments);
  },
  isDoWhileStatement(value     , opts         )          {
    return t.isDoWhileStatement.apply(t, arguments);
  },
  isEmptyStatement(value     , opts         )          {
    return t.isEmptyStatement.apply(t, arguments);
  },
  isEmptyTypeAnnotation(value     , opts         )          {
    return t.isEmptyTypeAnnotation.apply(t, arguments);
  },
  isExistentialTypeParam(value     , opts         )          {
    return t.isExistentialTypeParam.apply(t, arguments);
  },
  isExportAllDeclaration(value     , opts         )          {
    return t.isExportAllDeclaration.apply(t, arguments);
  },
  isExportDefaultDeclaration(value     , opts         )          {
    return t.isExportDefaultDeclaration.apply(t, arguments);
  },
  isExportDefaultSpecifier(value     , opts         )          {
    return t.isExportDefaultSpecifier.apply(t, arguments);
  },
  isExportNamedDeclaration(value     , opts         )          {
    return t.isExportNamedDeclaration.apply(t, arguments);
  },
  isExportNamespaceSpecifier(value     , opts         )          {
    return t.isExportNamespaceSpecifier.apply(t, arguments);
  },
  isExportSpecifier(value     , opts         )          {
    return t.isExportSpecifier.apply(t, arguments);
  },
  isExpressionStatement(value     , opts         )          {
    return t.isExpressionStatement.apply(t, arguments);
  },
  isFile(value     , opts         )          {
    return t.isFile.apply(t, arguments);
  },
  isForAwaitStatement(value     , opts         )          {
    return t.isForAwaitStatement.apply(t, arguments);
  },
  isForInStatement(value     , opts         )          {
    return t.isForInStatement.apply(t, arguments);
  },
  isForOfStatement(value     , opts         )          {
    return t.isForOfStatement.apply(t, arguments);
  },
  isForStatement(value     , opts         )          {
    return t.isForStatement.apply(t, arguments);
  },
  isFunctionDeclaration(value     , opts         )          {
    return t.isFunctionDeclaration.apply(t, arguments);
  },
  isFunctionExpression(value     , opts         )          {
    return t.isFunctionExpression.apply(t, arguments);
  },
  isFunctionTypeAnnotation(value     , opts         )          {
    return t.isFunctionTypeAnnotation.apply(t, arguments);
  },
  isFunctionTypeParam(value     , opts         )          {
    return t.isFunctionTypeParam.apply(t, arguments);
  },
  isGenericTypeAnnotation(value     , opts         )          {
    return t.isGenericTypeAnnotation.apply(t, arguments);
  },
  isIdentifier(value     , opts         )          {
    return t.isIdentifier.apply(t, arguments);
  },
  isIfStatement(value     , opts         )          {
    return t.isIfStatement.apply(t, arguments);
  },
  isImport(value     , opts         )          {
    return t.isImport.apply(t, arguments);
  },
  isImportDeclaration(value     , opts         )          {
    return t.isImportDeclaration.apply(t, arguments);
  },
  isImportDefaultSpecifier(value     , opts         )          {
    return t.isImportDefaultSpecifier.apply(t, arguments);
  },
  isImportNamespaceSpecifier(value     , opts         )          {
    return t.isImportNamespaceSpecifier.apply(t, arguments);
  },
  isImportSpecifier(value     , opts         )          {
    return t.isImportSpecifier.apply(t, arguments);
  },
  isInterfaceDeclaration(value     , opts         )          {
    return t.isInterfaceDeclaration.apply(t, arguments);
  },
  isInterfaceExtends(value     , opts         )          {
    return t.isInterfaceExtends.apply(t, arguments);
  },
  isIntersectionTypeAnnotation(value     , opts         )          {
    return t.isIntersectionTypeAnnotation.apply(t, arguments);
  },
  isJSXAttribute(value     , opts         )          {
    return t.isJSXAttribute.apply(t, arguments);
  },
  isJSXClosingElement(value     , opts         )          {
    return t.isJSXClosingElement.apply(t, arguments);
  },
  isJSXElement(value     , opts         )          {
    return t.isJSXElement.apply(t, arguments);
  },
  isJSXEmptyExpression(value     , opts         )          {
    return t.isJSXEmptyExpression.apply(t, arguments);
  },
  isJSXExpressionContainer(value     , opts         )          {
    return t.isJSXExpressionContainer.apply(t, arguments);
  },
  isJSXIdentifier(value     , opts         )          {
    return t.isJSXIdentifier.apply(t, arguments);
  },
  isJSXMemberExpression(value     , opts         )          {
    return t.isJSXMemberExpression.apply(t, arguments);
  },
  isJSXNamespacedName(value     , opts         )          {
    return t.isJSXNamespacedName.apply(t, arguments);
  },
  isJSXOpeningElement(value     , opts         )          {
    return t.isJSXOpeningElement.apply(t, arguments);
  },
  isJSXSpreadAttribute(value     , opts         )          {
    return t.isJSXSpreadAttribute.apply(t, arguments);
  },
  isJSXSpreadChild(value     , opts         )          {
    return t.isJSXSpreadChild.apply(t, arguments);
  },
  isJSXText(value     , opts         )          {
    return t.isJSXText.apply(t, arguments);
  },
  isLabeledStatement(value     , opts         )          {
    return t.isLabeledStatement.apply(t, arguments);
  },
  isLogicalExpression(value     , opts         )          {
    return t.isLogicalExpression.apply(t, arguments);
  },
  isMemberExpression(value     , opts         )          {
    return t.isMemberExpression.apply(t, arguments);
  },
  isMetaProperty(value     , opts         )          {
    return t.isMetaProperty.apply(t, arguments);
  },
  isMixedTypeAnnotation(value     , opts         )          {
    return t.isMixedTypeAnnotation.apply(t, arguments);
  },
  isNewExpression(value     , opts         )          {
    return t.isNewExpression.apply(t, arguments);
  },
  isNoop(value     , opts         )          {
    return t.isNoop.apply(t, arguments);
  },
  isNullLiteral(value     , opts         )          {
    return t.isNullLiteral.apply(t, arguments);
  },
  isNullLiteralTypeAnnotation(value     , opts         )          {
    return t.isNullLiteralTypeAnnotation.apply(t, arguments);
  },
  isNullableTypeAnnotation(value     , opts         )          {
    return t.isNullableTypeAnnotation.apply(t, arguments);
  },
  isNumberTypeAnnotation(value     , opts         )          {
    return t.isNumberTypeAnnotation.apply(t, arguments);
  },
  isNumericLiteral(value     , opts         )          {
    return t.isNumericLiteral.apply(t, arguments);
  },
  isNumericLiteralTypeAnnotation(value     , opts         )          {
    return t.isNumericLiteralTypeAnnotation.apply(t, arguments);
  },
  isObjectExpression(value     , opts         )          {
    return t.isObjectExpression.apply(t, arguments);
  },
  isObjectMethod(value     , opts         )          {
    return t.isObjectMethod.apply(t, arguments);
  },
  isObjectPattern(value     , opts         )          {
    return t.isObjectPattern.apply(t, arguments);
  },
  isObjectProperty(value     , opts         )          {
    return t.isObjectProperty.apply(t, arguments);
  },
  isObjectTypeAnnotation(value     , opts         )          {
    return t.isObjectTypeAnnotation.apply(t, arguments);
  },
  isObjectTypeCallProperty(value     , opts         )          {
    return t.isObjectTypeCallProperty.apply(t, arguments);
  },
  isObjectTypeIndexer(value     , opts         )          {
    return t.isObjectTypeIndexer.apply(t, arguments);
  },
  isObjectTypeProperty(value     , opts         )          {
    return t.isObjectTypeProperty.apply(t, arguments);
  },
  isParenthesizedExpression(value     , opts         )          {
    return t.isParenthesizedExpression.apply(t, arguments);
  },
  isProgram(value     , opts         )          {
    return t.isProgram.apply(t, arguments);
  },
  isQualifiedTypeIdentifier(value     , opts         )          {
    return t.isQualifiedTypeIdentifier.apply(t, arguments);
  },
  isRegExpLiteral(value     , opts         )          {
    return t.isRegExpLiteral.apply(t, arguments);
  },
  isRestElement(value     , opts         )          {
    return t.isRestElement.apply(t, arguments);
  },
  isRestProperty(value     , opts         )          {
    return t.isRestProperty.apply(t, arguments);
  },
  isReturnStatement(value     , opts         )          {
    return t.isReturnStatement.apply(t, arguments);
  },
  isSequenceExpression(value     , opts         )          {
    return t.isSequenceExpression.apply(t, arguments);
  },
  isSpreadElement(value     , opts         )          {
    return t.isSpreadElement.apply(t, arguments);
  },
  isSpreadProperty(value     , opts         )          {
    return t.isSpreadProperty.apply(t, arguments);
  },
  isStringLiteral(value     , opts         )          {
    return t.isStringLiteral.apply(t, arguments);
  },
  isStringLiteralTypeAnnotation(value     , opts         )          {
    return t.isStringLiteralTypeAnnotation.apply(t, arguments);
  },
  isStringTypeAnnotation(value     , opts         )          {
    return t.isStringTypeAnnotation.apply(t, arguments);
  },
  isSuper(value     , opts         )          {
    return t.isSuper.apply(t, arguments);
  },
  isSwitchCase(value     , opts         )          {
    return t.isSwitchCase.apply(t, arguments);
  },
  isSwitchStatement(value     , opts         )          {
    return t.isSwitchStatement.apply(t, arguments);
  },
  isTaggedTemplateExpression(value     , opts         )          {
    return t.isTaggedTemplateExpression.apply(t, arguments);
  },
  isTemplateElement(value     , opts         )          {
    return t.isTemplateElement.apply(t, arguments);
  },
  isTemplateLiteral(value     , opts         )          {
    return t.isTemplateLiteral.apply(t, arguments);
  },
  isThisExpression(value     , opts         )          {
    return t.isThisExpression.apply(t, arguments);
  },
  isThisTypeAnnotation(value     , opts         )          {
    return t.isThisTypeAnnotation.apply(t, arguments);
  },
  isThrowStatement(value     , opts         )          {
    return t.isThrowStatement.apply(t, arguments);
  },
  isTryStatement(value     , opts         )          {
    return t.isTryStatement.apply(t, arguments);
  },
  isTupleTypeAnnotation(value     , opts         )          {
    return t.isTupleTypeAnnotation.apply(t, arguments);
  },
  isTypeAlias(value     , opts         )          {
    return t.isTypeAlias.apply(t, arguments);
  },
  isTypeAnnotation(value     , opts         )          {
    return t.isTypeAnnotation.apply(t, arguments);
  },
  isTypeCastExpression(value     , opts         )          {
    return t.isTypeCastExpression.apply(t, arguments);
  },
  isTypeParameter(value     , opts         )          {
    return t.isTypeParameter.apply(t, arguments);
  },
  isTypeParameterDeclaration(value     , opts         )          {
    return t.isTypeParameterDeclaration.apply(t, arguments);
  },
  isTypeParameterInstantiation(value     , opts         )          {
    return t.isTypeParameterInstantiation.apply(t, arguments);
  },
  isTypeofTypeAnnotation(value     , opts         )          {
    return t.isTypeofTypeAnnotation.apply(t, arguments);
  },
  isUnaryExpression(value     , opts         )          {
    return t.isUnaryExpression.apply(t, arguments);
  },
  isUnionTypeAnnotation(value     , opts         )          {
    return t.isUnionTypeAnnotation.apply(t, arguments);
  },
  isUpdateExpression(value     , opts         )          {
    return t.isUpdateExpression.apply(t, arguments);
  },
  isVariableDeclaration(value     , opts         )          {
    return t.isVariableDeclaration.apply(t, arguments);
  },
  isVariableDeclarator(value     , opts         )          {
    return t.isVariableDeclarator.apply(t, arguments);
  },
  isVoidTypeAnnotation(value     , opts         )          {
    return t.isVoidTypeAnnotation.apply(t, arguments);
  },
  isWhileStatement(value     , opts         )          {
    return t.isWhileStatement.apply(t, arguments);
  },
  isWithStatement(value     , opts         )          {
    return t.isWithStatement.apply(t, arguments);
  },
  isYieldExpression(value     , opts         )          {
    return t.isYieldExpression.apply(t, arguments);
  },
  assertAnyTypeAnnotation(value                   , opts         )        {
    return t.assertAnyTypeAnnotation.apply(t, arguments);
  },
  assertArrayExpression(value                 , opts         )        {
    return t.assertArrayExpression.apply(t, arguments);
  },
  assertArrayPattern(value              , opts         )        {
    return t.assertArrayPattern.apply(t, arguments);
  },
  assertArrayTypeAnnotation(value                     , opts         )        {
    return t.assertArrayTypeAnnotation.apply(t, arguments);
  },
  assertArrowFunctionExpression(value                         , opts         )        {
    return t.assertArrowFunctionExpression.apply(t, arguments);
  },
  assertAssignmentExpression(value                      , opts         )        {
    return t.assertAssignmentExpression.apply(t, arguments);
  },
  assertAssignmentPattern(value                   , opts         )        {
    return t.assertAssignmentPattern.apply(t, arguments);
  },
  assertAwaitExpression(value                 , opts         )        {
    return t.assertAwaitExpression.apply(t, arguments);
  },
  assertBinaryExpression(value                  , opts         )        {
    return t.assertBinaryExpression.apply(t, arguments);
  },
  assertBindExpression(value                , opts         )        {
    return t.assertBindExpression.apply(t, arguments);
  },
  assertBlockStatement(value                , opts         )        {
    return t.assertBlockStatement.apply(t, arguments);
  },
  assertBooleanLiteral(value                , opts         )        {
    return t.assertBooleanLiteral.apply(t, arguments);
  },
  assertBooleanLiteralTypeAnnotation(value                              , opts         )        {
    return t.assertBooleanLiteralTypeAnnotation.apply(t, arguments);
  },
  assertBooleanTypeAnnotation(value                       , opts         )        {
    return t.assertBooleanTypeAnnotation.apply(t, arguments);
  },
  assertBreakStatement(value                , opts         )        {
    return t.assertBreakStatement.apply(t, arguments);
  },
  assertCallExpression(value                , opts         )        {
    return t.assertCallExpression.apply(t, arguments);
  },
  assertCatchClause(value             , opts         )        {
    return t.assertCatchClause.apply(t, arguments);
  },
  assertClassBody(value           , opts         )        {
    return t.assertClassBody.apply(t, arguments);
  },
  assertClassDeclaration(value                  , opts         )        {
    return t.assertClassDeclaration.apply(t, arguments);
  },
  assertClassExpression(value                 , opts         )        {
    return t.assertClassExpression.apply(t, arguments);
  },
  assertClassImplements(value                 , opts         )        {
    return t.assertClassImplements.apply(t, arguments);
  },
  assertClassMethod(value             , opts         )        {
    return t.assertClassMethod.apply(t, arguments);
  },
  assertClassProperty(value               , opts         )        {
    return t.assertClassProperty.apply(t, arguments);
  },
  assertConditionalExpression(value                       , opts         )        {
    return t.assertConditionalExpression.apply(t, arguments);
  },
  assertContinueStatement(value                   , opts         )        {
    return t.assertContinueStatement.apply(t, arguments);
  },
  assertDebuggerStatement(value                   , opts         )        {
    return t.assertDebuggerStatement.apply(t, arguments);
  },
  assertDeclareClass(value              , opts         )        {
    return t.assertDeclareClass.apply(t, arguments);
  },
  assertDeclareFunction(value                 , opts         )        {
    return t.assertDeclareFunction.apply(t, arguments);
  },
  assertDeclareInterface(value                  , opts         )        {
    return t.assertDeclareInterface.apply(t, arguments);
  },
  assertDeclareModule(value               , opts         )        {
    return t.assertDeclareModule.apply(t, arguments);
  },
  assertDeclareModuleExports(value                      , opts         )        {
    return t.assertDeclareModuleExports.apply(t, arguments);
  },
  assertDeclareTypeAlias(value                  , opts         )        {
    return t.assertDeclareTypeAlias.apply(t, arguments);
  },
  assertDeclareVariable(value                 , opts         )        {
    return t.assertDeclareVariable.apply(t, arguments);
  },
  assertDecorator(value           , opts         )        {
    return t.assertDecorator.apply(t, arguments);
  },
  assertDirective(value           , opts         )        {
    return t.assertDirective.apply(t, arguments);
  },
  assertDirectiveLiteral(value                  , opts         )        {
    return t.assertDirectiveLiteral.apply(t, arguments);
  },
  assertDoExpression(value              , opts         )        {
    return t.assertDoExpression.apply(t, arguments);
  },
  assertDoWhileStatement(value                  , opts         )        {
    return t.assertDoWhileStatement.apply(t, arguments);
  },
  assertEmptyStatement(value                , opts         )        {
    return t.assertEmptyStatement.apply(t, arguments);
  },
  assertEmptyTypeAnnotation(value                     , opts         )        {
    return t.assertEmptyTypeAnnotation.apply(t, arguments);
  },
  assertExistentialTypeParam(value                      , opts         )        {
    return t.assertExistentialTypeParam.apply(t, arguments);
  },
  assertExportAllDeclaration(value                      , opts         )        {
    return t.assertExportAllDeclaration.apply(t, arguments);
  },
  assertExportDefaultDeclaration(value                          , opts         )        {
    return t.assertExportDefaultDeclaration.apply(t, arguments);
  },
  assertExportDefaultSpecifier(value                        , opts         )        {
    return t.assertExportDefaultSpecifier.apply(t, arguments);
  },
  assertExportNamedDeclaration(value                        , opts         )        {
    return t.assertExportNamedDeclaration.apply(t, arguments);
  },
  assertExportNamespaceSpecifier(value                          , opts         )        {
    return t.assertExportNamespaceSpecifier.apply(t, arguments);
  },
  assertExportSpecifier(value                 , opts         )        {
    return t.assertExportSpecifier.apply(t, arguments);
  },
  assertExpressionStatement(value                     , opts         )        {
    return t.assertExpressionStatement.apply(t, arguments);
  },
  assertFile(value      , opts         )        {
    return t.assertFile.apply(t, arguments);
  },
  assertForAwaitStatement(value                   , opts         )        {
    return t.assertForAwaitStatement.apply(t, arguments);
  },
  assertForInStatement(value                , opts         )        {
    return t.assertForInStatement.apply(t, arguments);
  },
  assertForOfStatement(value                , opts         )        {
    return t.assertForOfStatement.apply(t, arguments);
  },
  assertForStatement(value              , opts         )        {
    return t.assertForStatement.apply(t, arguments);
  },
  assertFunctionDeclaration(value                     , opts         )        {
    return t.assertFunctionDeclaration.apply(t, arguments);
  },
  assertFunctionExpression(value                    , opts         )        {
    return t.assertFunctionExpression.apply(t, arguments);
  },
  assertFunctionTypeAnnotation(value                        , opts         )        {
    return t.assertFunctionTypeAnnotation.apply(t, arguments);
  },
  assertFunctionTypeParam(value                   , opts         )        {
    return t.assertFunctionTypeParam.apply(t, arguments);
  },
  assertGenericTypeAnnotation(value                       , opts         )        {
    return t.assertGenericTypeAnnotation.apply(t, arguments);
  },
  assertIdentifier(value            , opts         )        {
    return t.assertIdentifier.apply(t, arguments);
  },
  assertIfStatement(value             , opts         )        {
    return t.assertIfStatement.apply(t, arguments);
  },
  assertImport(value        , opts         )        {
    return t.assertImport.apply(t, arguments);
  },
  assertImportDeclaration(value                   , opts         )        {
    return t.assertImportDeclaration.apply(t, arguments);
  },
  assertImportDefaultSpecifier(value                        , opts         )        {
    return t.assertImportDefaultSpecifier.apply(t, arguments);
  },
  assertImportNamespaceSpecifier(value                          , opts         )        {
    return t.assertImportNamespaceSpecifier.apply(t, arguments);
  },
  assertImportSpecifier(value                 , opts         )        {
    return t.assertImportSpecifier.apply(t, arguments);
  },
  assertInterfaceDeclaration(value                      , opts         )        {
    return t.assertInterfaceDeclaration.apply(t, arguments);
  },
  assertInterfaceExtends(value                  , opts         )        {
    return t.assertInterfaceExtends.apply(t, arguments);
  },
  assertIntersectionTypeAnnotation(value                            , opts         )        {
    return t.assertIntersectionTypeAnnotation.apply(t, arguments);
  },
  assertJSXAttribute(value              , opts         )        {
    return t.assertJSXAttribute.apply(t, arguments);
  },
  assertJSXClosingElement(value                   , opts         )        {
    return t.assertJSXClosingElement.apply(t, arguments);
  },
  assertJSXElement(value            , opts         )        {
    return t.assertJSXElement.apply(t, arguments);
  },
  assertJSXEmptyExpression(value                    , opts         )        {
    return t.assertJSXEmptyExpression.apply(t, arguments);
  },
  assertJSXExpressionContainer(value                        , opts         )        {
    return t.assertJSXExpressionContainer.apply(t, arguments);
  },
  assertJSXIdentifier(value               , opts         )        {
    return t.assertJSXIdentifier.apply(t, arguments);
  },
  assertJSXMemberExpression(value                     , opts         )        {
    return t.assertJSXMemberExpression.apply(t, arguments);
  },
  assertJSXNamespacedName(value                   , opts         )        {
    return t.assertJSXNamespacedName.apply(t, arguments);
  },
  assertJSXOpeningElement(value                   , opts         )        {
    return t.assertJSXOpeningElement.apply(t, arguments);
  },
  assertJSXSpreadAttribute(value                    , opts         )        {
    return t.assertJSXSpreadAttribute.apply(t, arguments);
  },
  assertJSXSpreadChild(value                , opts         )        {
    return t.assertJSXSpreadChild.apply(t, arguments);
  },
  assertJSXText(value         , opts         )        {
    return t.assertJSXText.apply(t, arguments);
  },
  assertLabeledStatement(value                  , opts         )        {
    return t.assertLabeledStatement.apply(t, arguments);
  },
  assertLogicalExpression(value                   , opts         )        {
    return t.assertLogicalExpression.apply(t, arguments);
  },
  assertMemberExpression(value                  , opts         )        {
    return t.assertMemberExpression.apply(t, arguments);
  },
  assertMetaProperty(value              , opts         )        {
    return t.assertMetaProperty.apply(t, arguments);
  },
  assertMixedTypeAnnotation(value                     , opts         )        {
    return t.assertMixedTypeAnnotation.apply(t, arguments);
  },
  assertNewExpression(value               , opts         )        {
    return t.assertNewExpression.apply(t, arguments);
  },
  assertNoop(value      , opts         )        {
    return t.assertNoop.apply(t, arguments);
  },
  assertNullLiteral(value             , opts         )        {
    return t.assertNullLiteral.apply(t, arguments);
  },
  assertNullLiteralTypeAnnotation(value                           , opts         )        {
    return t.assertNullLiteralTypeAnnotation.apply(t, arguments);
  },
  assertNullableTypeAnnotation(value                        , opts         )        {
    return t.assertNullableTypeAnnotation.apply(t, arguments);
  },
  assertNumberTypeAnnotation(value                      , opts         )        {
    return t.assertNumberTypeAnnotation.apply(t, arguments);
  },
  assertNumericLiteral(value                , opts         )        {
    return t.assertNumericLiteral.apply(t, arguments);
  },
  assertNumericLiteralTypeAnnotation(value                              , opts         )        {
    return t.assertNumericLiteralTypeAnnotation.apply(t, arguments);
  },
  assertObjectExpression(value                  , opts         )        {
    return t.assertObjectExpression.apply(t, arguments);
  },
  assertObjectMethod(value              , opts         )        {
    return t.assertObjectMethod.apply(t, arguments);
  },
  assertObjectPattern(value               , opts         )        {
    return t.assertObjectPattern.apply(t, arguments);
  },
  assertObjectProperty(value                , opts         )        {
    return t.assertObjectProperty.apply(t, arguments);
  },
  assertObjectTypeAnnotation(value                      , opts         )        {
    return t.assertObjectTypeAnnotation.apply(t, arguments);
  },
  assertObjectTypeCallProperty(value                        , opts         )        {
    return t.assertObjectTypeCallProperty.apply(t, arguments);
  },
  assertObjectTypeIndexer(value                   , opts         )        {
    return t.assertObjectTypeIndexer.apply(t, arguments);
  },
  assertObjectTypeProperty(value                    , opts         )        {
    return t.assertObjectTypeProperty.apply(t, arguments);
  },
  assertParenthesizedExpression(value                         , opts         )        {
    return t.assertParenthesizedExpression.apply(t, arguments);
  },
  assertProgram(value         , opts         )        {
    return t.assertProgram.apply(t, arguments);
  },
  assertQualifiedTypeIdentifier(value                         , opts         )        {
    return t.assertQualifiedTypeIdentifier.apply(t, arguments);
  },
  assertRegExpLiteral(value               , opts         )        {
    return t.assertRegExpLiteral.apply(t, arguments);
  },
  assertRestElement(value             , opts         )        {
    return t.assertRestElement.apply(t, arguments);
  },
  assertRestProperty(value              , opts         )        {
    return t.assertRestProperty.apply(t, arguments);
  },
  assertReturnStatement(value                 , opts         )        {
    return t.assertReturnStatement.apply(t, arguments);
  },
  assertSequenceExpression(value                    , opts         )        {
    return t.assertSequenceExpression.apply(t, arguments);
  },
  assertSpreadElement(value               , opts         )        {
    return t.assertSpreadElement.apply(t, arguments);
  },
  assertSpreadProperty(value                , opts         )        {
    return t.assertSpreadProperty.apply(t, arguments);
  },
  assertStringLiteral(value               , opts         )        {
    return t.assertStringLiteral.apply(t, arguments);
  },
  assertStringLiteralTypeAnnotation(value                             , opts         )        {
    return t.assertStringLiteralTypeAnnotation.apply(t, arguments);
  },
  assertStringTypeAnnotation(value                      , opts         )        {
    return t.assertStringTypeAnnotation.apply(t, arguments);
  },
  assertSuper(value       , opts         )        {
    return t.assertSuper.apply(t, arguments);
  },
  assertSwitchCase(value            , opts         )        {
    return t.assertSwitchCase.apply(t, arguments);
  },
  assertSwitchStatement(value                 , opts         )        {
    return t.assertSwitchStatement.apply(t, arguments);
  },
  assertTaggedTemplateExpression(value                          , opts         )        {
    return t.assertTaggedTemplateExpression.apply(t, arguments);
  },
  assertTemplateElement(value                 , opts         )        {
    return t.assertTemplateElement.apply(t, arguments);
  },
  assertTemplateLiteral(value                 , opts         )        {
    return t.assertTemplateLiteral.apply(t, arguments);
  },
  assertThisExpression(value                , opts         )        {
    return t.assertThisExpression.apply(t, arguments);
  },
  assertThisTypeAnnotation(value                    , opts         )        {
    return t.assertThisTypeAnnotation.apply(t, arguments);
  },
  assertThrowStatement(value                , opts         )        {
    return t.assertThrowStatement.apply(t, arguments);
  },
  assertTryStatement(value              , opts         )        {
    return t.assertTryStatement.apply(t, arguments);
  },
  assertTupleTypeAnnotation(value                     , opts         )        {
    return t.assertTupleTypeAnnotation.apply(t, arguments);
  },
  assertTypeAlias(value           , opts         )        {
    return t.assertTypeAlias.apply(t, arguments);
  },
  assertTypeAnnotation(value                , opts         )        {
    return t.assertTypeAnnotation.apply(t, arguments);
  },
  assertTypeCastExpression(value                    , opts         )        {
    return t.assertTypeCastExpression.apply(t, arguments);
  },
  assertTypeParameter(value               , opts         )        {
    return t.assertTypeParameter.apply(t, arguments);
  },
  assertTypeParameterDeclaration(value                          , opts         )        {
    return t.assertTypeParameterDeclaration.apply(t, arguments);
  },
  assertTypeParameterInstantiation(value                            , opts         )        {
    return t.assertTypeParameterInstantiation.apply(t, arguments);
  },
  assertTypeofTypeAnnotation(value                      , opts         )        {
    return t.assertTypeofTypeAnnotation.apply(t, arguments);
  },
  assertUnaryExpression(value                 , opts         )        {
    return t.assertUnaryExpression.apply(t, arguments);
  },
  assertUnionTypeAnnotation(value                     , opts         )        {
    return t.assertUnionTypeAnnotation.apply(t, arguments);
  },
  assertUpdateExpression(value                  , opts         )        {
    return t.assertUpdateExpression.apply(t, arguments);
  },
  assertVariableDeclaration(value                     , opts         )        {
    return t.assertVariableDeclaration.apply(t, arguments);
  },
  assertVariableDeclarator(value                    , opts         )        {
    return t.assertVariableDeclarator.apply(t, arguments);
  },
  assertVoidTypeAnnotation(value                    , opts         )        {
    return t.assertVoidTypeAnnotation.apply(t, arguments);
  },
  assertWhileStatement(value                , opts         )        {
    return t.assertWhileStatement.apply(t, arguments);
  },
  assertWithStatement(value               , opts         )        {
    return t.assertWithStatement.apply(t, arguments);
  },
  assertYieldExpression(value                 , opts         )        {
    return t.assertYieldExpression.apply(t, arguments);
  },
  asAnyTypeAnnotation(value     , opts         )                           {
    return t.isAnyTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asArrayExpression(value     , opts         )                         {
    return t.isArrayExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asArrayPattern(value     , opts         )                      {
    return t.isArrayPattern.apply(t, arguments) ? (value     ) : undefined;
  },
  asArrayTypeAnnotation(value     , opts         )                             {
    return t.isArrayTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asArrowFunctionExpression(value     , opts         )                                 {
    return t.isArrowFunctionExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asAssignmentExpression(value     , opts         )                              {
    return t.isAssignmentExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asAssignmentPattern(value     , opts         )                           {
    return t.isAssignmentPattern.apply(t, arguments) ? (value     ) : undefined;
  },
  asAwaitExpression(value     , opts         )                         {
    return t.isAwaitExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asBinaryExpression(value     , opts         )                          {
    return t.isBinaryExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asBindExpression(value     , opts         )                        {
    return t.isBindExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asBlockStatement(value     , opts         )                        {
    return t.isBlockStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asBooleanLiteral(value     , opts         )                        {
    return t.isBooleanLiteral.apply(t, arguments) ? (value     ) : undefined;
  },
  asBooleanLiteralTypeAnnotation(value     , opts         )                                      {
    return t.isBooleanLiteralTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asBooleanTypeAnnotation(value     , opts         )                               {
    return t.isBooleanTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asBreakStatement(value     , opts         )                        {
    return t.isBreakStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asCallExpression(value     , opts         )                        {
    return t.isCallExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asCatchClause(value     , opts         )                     {
    return t.isCatchClause.apply(t, arguments) ? (value     ) : undefined;
  },
  asClassBody(value     , opts         )                   {
    return t.isClassBody.apply(t, arguments) ? (value     ) : undefined;
  },
  asClassDeclaration(value     , opts         )                          {
    return t.isClassDeclaration.apply(t, arguments) ? (value     ) : undefined;
  },
  asClassExpression(value     , opts         )                         {
    return t.isClassExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asClassImplements(value     , opts         )                         {
    return t.isClassImplements.apply(t, arguments) ? (value     ) : undefined;
  },
  asClassMethod(value     , opts         )                     {
    return t.isClassMethod.apply(t, arguments) ? (value     ) : undefined;
  },
  asClassProperty(value     , opts         )                       {
    return t.isClassProperty.apply(t, arguments) ? (value     ) : undefined;
  },
  asConditionalExpression(value     , opts         )                               {
    return t.isConditionalExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asContinueStatement(value     , opts         )                           {
    return t.isContinueStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asDebuggerStatement(value     , opts         )                           {
    return t.isDebuggerStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asDeclareClass(value     , opts         )                      {
    return t.isDeclareClass.apply(t, arguments) ? (value     ) : undefined;
  },
  asDeclareFunction(value     , opts         )                         {
    return t.isDeclareFunction.apply(t, arguments) ? (value     ) : undefined;
  },
  asDeclareInterface(value     , opts         )                          {
    return t.isDeclareInterface.apply(t, arguments) ? (value     ) : undefined;
  },
  asDeclareModule(value     , opts         )                       {
    return t.isDeclareModule.apply(t, arguments) ? (value     ) : undefined;
  },
  asDeclareModuleExports(value     , opts         )                              {
    return t.isDeclareModuleExports.apply(t, arguments) ? (value     ) : undefined;
  },
  asDeclareTypeAlias(value     , opts         )                          {
    return t.isDeclareTypeAlias.apply(t, arguments) ? (value     ) : undefined;
  },
  asDeclareVariable(value     , opts         )                         {
    return t.isDeclareVariable.apply(t, arguments) ? (value     ) : undefined;
  },
  asDecorator(value     , opts         )                   {
    return t.isDecorator.apply(t, arguments) ? (value     ) : undefined;
  },
  asDirective(value     , opts         )                   {
    return t.isDirective.apply(t, arguments) ? (value     ) : undefined;
  },
  asDirectiveLiteral(value     , opts         )                          {
    return t.isDirectiveLiteral.apply(t, arguments) ? (value     ) : undefined;
  },
  asDoExpression(value     , opts         )                      {
    return t.isDoExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asDoWhileStatement(value     , opts         )                          {
    return t.isDoWhileStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asEmptyStatement(value     , opts         )                        {
    return t.isEmptyStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asEmptyTypeAnnotation(value     , opts         )                             {
    return t.isEmptyTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asExistentialTypeParam(value     , opts         )                              {
    return t.isExistentialTypeParam.apply(t, arguments) ? (value     ) : undefined;
  },
  asExportAllDeclaration(value     , opts         )                              {
    return t.isExportAllDeclaration.apply(t, arguments) ? (value     ) : undefined;
  },
  asExportDefaultDeclaration(value     , opts         )                                  {
    return t.isExportDefaultDeclaration.apply(t, arguments) ? (value     ) : undefined;
  },
  asExportDefaultSpecifier(value     , opts         )                                {
    return t.isExportDefaultSpecifier.apply(t, arguments) ? (value     ) : undefined;
  },
  asExportNamedDeclaration(value     , opts         )                                {
    return t.isExportNamedDeclaration.apply(t, arguments) ? (value     ) : undefined;
  },
  asExportNamespaceSpecifier(value     , opts         )                                  {
    return t.isExportNamespaceSpecifier.apply(t, arguments) ? (value     ) : undefined;
  },
  asExportSpecifier(value     , opts         )                         {
    return t.isExportSpecifier.apply(t, arguments) ? (value     ) : undefined;
  },
  asExpressionStatement(value     , opts         )                             {
    return t.isExpressionStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asFile(value     , opts         )              {
    return t.isFile.apply(t, arguments) ? (value     ) : undefined;
  },
  asForAwaitStatement(value     , opts         )                           {
    return t.isForAwaitStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asForInStatement(value     , opts         )                        {
    return t.isForInStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asForOfStatement(value     , opts         )                        {
    return t.isForOfStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asForStatement(value     , opts         )                      {
    return t.isForStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asFunctionDeclaration(value     , opts         )                             {
    return t.isFunctionDeclaration.apply(t, arguments) ? (value     ) : undefined;
  },
  asFunctionExpression(value     , opts         )                            {
    return t.isFunctionExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asFunctionTypeAnnotation(value     , opts         )                                {
    return t.isFunctionTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asFunctionTypeParam(value     , opts         )                           {
    return t.isFunctionTypeParam.apply(t, arguments) ? (value     ) : undefined;
  },
  asGenericTypeAnnotation(value     , opts         )                               {
    return t.isGenericTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asIdentifier(value     , opts         )                    {
    return t.isIdentifier.apply(t, arguments) ? (value     ) : undefined;
  },
  asIfStatement(value     , opts         )                     {
    return t.isIfStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asImport(value     , opts         )                {
    return t.isImport.apply(t, arguments) ? (value     ) : undefined;
  },
  asImportDeclaration(value     , opts         )                           {
    return t.isImportDeclaration.apply(t, arguments) ? (value     ) : undefined;
  },
  asImportDefaultSpecifier(value     , opts         )                                {
    return t.isImportDefaultSpecifier.apply(t, arguments) ? (value     ) : undefined;
  },
  asImportNamespaceSpecifier(value     , opts         )                                  {
    return t.isImportNamespaceSpecifier.apply(t, arguments) ? (value     ) : undefined;
  },
  asImportSpecifier(value     , opts         )                         {
    return t.isImportSpecifier.apply(t, arguments) ? (value     ) : undefined;
  },
  asInterfaceDeclaration(value     , opts         )                              {
    return t.isInterfaceDeclaration.apply(t, arguments) ? (value     ) : undefined;
  },
  asInterfaceExtends(value     , opts         )                          {
    return t.isInterfaceExtends.apply(t, arguments) ? (value     ) : undefined;
  },
  asIntersectionTypeAnnotation(value     , opts         )                                    {
    return t.isIntersectionTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXAttribute(value     , opts         )                      {
    return t.isJSXAttribute.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXClosingElement(value     , opts         )                           {
    return t.isJSXClosingElement.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXElement(value     , opts         )                    {
    return t.isJSXElement.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXEmptyExpression(value     , opts         )                            {
    return t.isJSXEmptyExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXExpressionContainer(value     , opts         )                                {
    return t.isJSXExpressionContainer.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXIdentifier(value     , opts         )                       {
    return t.isJSXIdentifier.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXMemberExpression(value     , opts         )                             {
    return t.isJSXMemberExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXNamespacedName(value     , opts         )                           {
    return t.isJSXNamespacedName.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXOpeningElement(value     , opts         )                           {
    return t.isJSXOpeningElement.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXSpreadAttribute(value     , opts         )                            {
    return t.isJSXSpreadAttribute.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXSpreadChild(value     , opts         )                        {
    return t.isJSXSpreadChild.apply(t, arguments) ? (value     ) : undefined;
  },
  asJSXText(value     , opts         )                 {
    return t.isJSXText.apply(t, arguments) ? (value     ) : undefined;
  },
  asLabeledStatement(value     , opts         )                          {
    return t.isLabeledStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asLogicalExpression(value     , opts         )                           {
    return t.isLogicalExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asMemberExpression(value     , opts         )                          {
    return t.isMemberExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asMetaProperty(value     , opts         )                      {
    return t.isMetaProperty.apply(t, arguments) ? (value     ) : undefined;
  },
  asMixedTypeAnnotation(value     , opts         )                             {
    return t.isMixedTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asNewExpression(value     , opts         )                       {
    return t.isNewExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asNoop(value     , opts         )              {
    return t.isNoop.apply(t, arguments) ? (value     ) : undefined;
  },
  asNullLiteral(value     , opts         )                     {
    return t.isNullLiteral.apply(t, arguments) ? (value     ) : undefined;
  },
  asNullLiteralTypeAnnotation(value     , opts         )                                   {
    return t.isNullLiteralTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asNullableTypeAnnotation(value     , opts         )                                {
    return t.isNullableTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asNumberTypeAnnotation(value     , opts         )                              {
    return t.isNumberTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asNumericLiteral(value     , opts         )                        {
    return t.isNumericLiteral.apply(t, arguments) ? (value     ) : undefined;
  },
  asNumericLiteralTypeAnnotation(value     , opts         )                                      {
    return t.isNumericLiteralTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asObjectExpression(value     , opts         )                          {
    return t.isObjectExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asObjectMethod(value     , opts         )                      {
    return t.isObjectMethod.apply(t, arguments) ? (value     ) : undefined;
  },
  asObjectPattern(value     , opts         )                       {
    return t.isObjectPattern.apply(t, arguments) ? (value     ) : undefined;
  },
  asObjectProperty(value     , opts         )                        {
    return t.isObjectProperty.apply(t, arguments) ? (value     ) : undefined;
  },
  asObjectTypeAnnotation(value     , opts         )                              {
    return t.isObjectTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asObjectTypeCallProperty(value     , opts         )                                {
    return t.isObjectTypeCallProperty.apply(t, arguments) ? (value     ) : undefined;
  },
  asObjectTypeIndexer(value     , opts         )                           {
    return t.isObjectTypeIndexer.apply(t, arguments) ? (value     ) : undefined;
  },
  asObjectTypeProperty(value     , opts         )                            {
    return t.isObjectTypeProperty.apply(t, arguments) ? (value     ) : undefined;
  },
  asParenthesizedExpression(value     , opts         )                                 {
    return t.isParenthesizedExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asProgram(value     , opts         )                 {
    return t.isProgram.apply(t, arguments) ? (value     ) : undefined;
  },
  asQualifiedTypeIdentifier(value     , opts         )                                 {
    return t.isQualifiedTypeIdentifier.apply(t, arguments) ? (value     ) : undefined;
  },
  asRegExpLiteral(value     , opts         )                       {
    return t.isRegExpLiteral.apply(t, arguments) ? (value     ) : undefined;
  },
  asRestElement(value     , opts         )                     {
    return t.isRestElement.apply(t, arguments) ? (value     ) : undefined;
  },
  asRestProperty(value     , opts         )                      {
    return t.isRestProperty.apply(t, arguments) ? (value     ) : undefined;
  },
  asReturnStatement(value     , opts         )                         {
    return t.isReturnStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asSequenceExpression(value     , opts         )                            {
    return t.isSequenceExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asSpreadElement(value     , opts         )                       {
    return t.isSpreadElement.apply(t, arguments) ? (value     ) : undefined;
  },
  asSpreadProperty(value     , opts         )                        {
    return t.isSpreadProperty.apply(t, arguments) ? (value     ) : undefined;
  },
  asStringLiteral(value     , opts         )                       {
    return t.isStringLiteral.apply(t, arguments) ? (value     ) : undefined;
  },
  asStringLiteralTypeAnnotation(value     , opts         )                                     {
    return t.isStringLiteralTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asStringTypeAnnotation(value     , opts         )                              {
    return t.isStringTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asSuper(value     , opts         )               {
    return t.isSuper.apply(t, arguments) ? (value     ) : undefined;
  },
  asSwitchCase(value     , opts         )                    {
    return t.isSwitchCase.apply(t, arguments) ? (value     ) : undefined;
  },
  asSwitchStatement(value     , opts         )                         {
    return t.isSwitchStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asTaggedTemplateExpression(value     , opts         )                                  {
    return t.isTaggedTemplateExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asTemplateElement(value     , opts         )                         {
    return t.isTemplateElement.apply(t, arguments) ? (value     ) : undefined;
  },
  asTemplateLiteral(value     , opts         )                         {
    return t.isTemplateLiteral.apply(t, arguments) ? (value     ) : undefined;
  },
  asThisExpression(value     , opts         )                        {
    return t.isThisExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asThisTypeAnnotation(value     , opts         )                            {
    return t.isThisTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asThrowStatement(value     , opts         )                        {
    return t.isThrowStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asTryStatement(value     , opts         )                      {
    return t.isTryStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asTupleTypeAnnotation(value     , opts         )                             {
    return t.isTupleTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asTypeAlias(value     , opts         )                   {
    return t.isTypeAlias.apply(t, arguments) ? (value     ) : undefined;
  },
  asTypeAnnotation(value     , opts         )                        {
    return t.isTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asTypeCastExpression(value     , opts         )                            {
    return t.isTypeCastExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asTypeParameter(value     , opts         )                       {
    return t.isTypeParameter.apply(t, arguments) ? (value     ) : undefined;
  },
  asTypeParameterDeclaration(value     , opts         )                                  {
    return t.isTypeParameterDeclaration.apply(t, arguments) ? (value     ) : undefined;
  },
  asTypeParameterInstantiation(value     , opts         )                                    {
    return t.isTypeParameterInstantiation.apply(t, arguments) ? (value     ) : undefined;
  },
  asTypeofTypeAnnotation(value     , opts         )                              {
    return t.isTypeofTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asUnaryExpression(value     , opts         )                         {
    return t.isUnaryExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asUnionTypeAnnotation(value     , opts         )                             {
    return t.isUnionTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asUpdateExpression(value     , opts         )                          {
    return t.isUpdateExpression.apply(t, arguments) ? (value     ) : undefined;
  },
  asVariableDeclaration(value     , opts         )                             {
    return t.isVariableDeclaration.apply(t, arguments) ? (value     ) : undefined;
  },
  asVariableDeclarator(value     , opts         )                            {
    return t.isVariableDeclarator.apply(t, arguments) ? (value     ) : undefined;
  },
  asVoidTypeAnnotation(value     , opts         )                            {
    return t.isVoidTypeAnnotation.apply(t, arguments) ? (value     ) : undefined;
  },
  asWhileStatement(value     , opts         )                        {
    return t.isWhileStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asWithStatement(value     , opts         )                       {
    return t.isWithStatement.apply(t, arguments) ? (value     ) : undefined;
  },
  asYieldExpression(value     , opts         )                         {
    return t.isYieldExpression.apply(t, arguments) ? (value     ) : undefined;
  },
}

module.exports = Object.assign ({}, BabelTypes, {
  getCurrentLocation: getCurrentLocation,
  setCurrentLocation: setCurrentLocation,
  setBabelTypes: setBabelTypes
})
