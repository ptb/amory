// generated by scripts/generate-babel-types.js

type Location = {start: {line: number, column: number}, end: {line: number, column: number}};

declare class AnyTypeAnnotation {
  type: 'AnyTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class ArrayExpression {
  type: 'ArrayExpression';
  loc: ?Location;
  elements: $ReadOnlyArray<null | Expression | SpreadElement>;

  // alias: Expression
  // alias: BabelNode
}

declare class ArrayPattern {
  type: 'ArrayPattern';
  loc: ?Location;
  elements: $ReadOnlyArray<Expression>;
  typeAnnotation: mixed;
  decorators: ?$ReadOnlyArray<Decorator>;

  // alias: Pattern
  // alias: LVal
  // alias: BabelNode
}

declare class ArrayTypeAnnotation {
  type: 'ArrayTypeAnnotation';
  loc: ?Location;
  elementType: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class ArrowFunctionExpression {
  type: 'ArrowFunctionExpression';
  loc: ?Location;
  params: $ReadOnlyArray<LVal>;
  body: BlockStatement | Expression;
  async: boolean;
  returnType: ?mixed;
  typeParameters: ?mixed;

  // alias: Scopable
  // alias: Function
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Expression
  // alias: Pureish
  // alias: BabelNode
}

declare class AssignmentExpression {
  type: 'AssignmentExpression';
  loc: ?Location;
  operator: string;
  left: LVal;
  right: Expression;

  // alias: Expression
  // alias: BabelNode
}

declare class AssignmentPattern {
  type: 'AssignmentPattern';
  loc: ?Location;
  left: Identifier;
  right: Expression;
  decorators: ?$ReadOnlyArray<Decorator>;

  // alias: Pattern
  // alias: LVal
  // alias: BabelNode
}

declare class AwaitExpression {
  type: 'AwaitExpression';
  loc: ?Location;
  argument: Expression;

  // alias: Expression
  // alias: Terminatorless
  // alias: BabelNode
}

declare class BinaryExpression {
  type: 'BinaryExpression';
  loc: ?Location;
  operator: '+' | '-' | '/' | '%' | '*' | '**' | '&' | '|' | '>>' | '>>>' | '<<' | '^' | '==' | '===' | '!=' | '!==' | 'in' | 'instanceof' | '>' | '<' | '>=' | '<=';
  left: Expression;
  right: Expression;

  // alias: Binary
  // alias: Expression
  // alias: BabelNode
}

declare class BindExpression {
  type: 'BindExpression';
  loc: ?Location;
  object: mixed;
  callee: mixed;

  // alias: Expression
  // alias: BabelNode
}

declare class BlockStatement {
  type: 'BlockStatement';
  loc: ?Location;
  body: $ReadOnlyArray<Statement>;
  directives: $ReadOnlyArray<Directive>;

  // alias: Scopable
  // alias: BlockParent
  // alias: Block
  // alias: Statement
  // alias: BabelNode
}

declare class BooleanLiteral {
  type: 'BooleanLiteral';
  loc: ?Location;
  value: boolean;

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: BabelNode
}

declare class BooleanLiteralTypeAnnotation {
  type: 'BooleanLiteralTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: BabelNode
}

declare class BooleanTypeAnnotation {
  type: 'BooleanTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class BreakStatement {
  type: 'BreakStatement';
  loc: ?Location;
  label: ?Identifier;

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: BabelNode
}

declare class CallExpression {
  type: 'CallExpression';
  loc: ?Location;
  callee: Expression;
  arguments: $ReadOnlyArray<Expression | SpreadElement>;

  // alias: Expression
  // alias: BabelNode
}

declare class CatchClause {
  type: 'CatchClause';
  loc: ?Location;
  param: Identifier;
  body: BlockStatement;

  // alias: Scopable
  // alias: BabelNode
}

declare class ClassBody {
  type: 'ClassBody';
  loc: ?Location;
  body: $ReadOnlyArray<ClassMethod | ClassProperty>;

  // alias: BabelNode
}

declare class ClassDeclaration {
  type: 'ClassDeclaration';
  loc: ?Location;
  id: Identifier;
  superClass: ?Expression;
  body: ClassBody;
  decorators: $ReadOnlyArray<Decorator>;
  implements: ?mixed;
  mixins: ?mixed;
  superTypeParameters: ?mixed;
  typeParameters: ?mixed;

  // alias: Scopable
  // alias: Class
  // alias: Statement
  // alias: Declaration
  // alias: Pureish
  // alias: BabelNode
}

declare class ClassExpression {
  type: 'ClassExpression';
  loc: ?Location;
  id: ?Identifier;
  superClass: ?Expression;
  body: ClassBody;
  decorators: $ReadOnlyArray<Decorator>;
  implements: ?mixed;
  mixins: ?mixed;
  superTypeParameters: ?mixed;
  typeParameters: ?mixed;

  // alias: Scopable
  // alias: Class
  // alias: Expression
  // alias: Pureish
  // alias: BabelNode
}

declare class ClassImplements {
  type: 'ClassImplements';
  loc: ?Location;
  id: mixed;
  typeParameters: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class ClassMethod {
  type: 'ClassMethod';
  loc: ?Location;
  kind: "get" | "set" | "method" | "constructor";
  key: Expression;
  params: $ReadOnlyArray<LVal>;
  body: BlockStatement;
  computed: boolean;
  async: ?boolean;
  decorators: ?mixed;
  generator: ?boolean;
  returnType: ?mixed;
  typeParameters: ?mixed;

  // alias: Function
  // alias: Scopable
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Method
  // alias: BabelNode
}

declare class ClassProperty {
  type: 'ClassProperty';
  loc: ?Location;
  key: mixed;
  value: mixed;
  typeAnnotation: mixed;
  decorators: mixed;
  computed: boolean;

  // alias: Property
  // alias: BabelNode
}

declare class ConditionalExpression {
  type: 'ConditionalExpression';
  loc: ?Location;
  test: Expression;
  consequent: Expression;
  alternate: Expression;

  // alias: Expression
  // alias: Conditional
  // alias: BabelNode
}

declare class ContinueStatement {
  type: 'ContinueStatement';
  loc: ?Location;
  label: ?Identifier;

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: BabelNode
}

declare class DebuggerStatement {
  type: 'DebuggerStatement';
  loc: ?Location;

  // alias: Statement
  // alias: BabelNode
}

declare class DeclareClass {
  type: 'DeclareClass';
  loc: ?Location;
  id: mixed;
  typeParameters: mixed;
  extends: mixed;
  body: mixed;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareFunction {
  type: 'DeclareFunction';
  loc: ?Location;
  id: mixed;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareInterface {
  type: 'DeclareInterface';
  loc: ?Location;
  id: mixed;
  typeParameters: mixed;
  extends: mixed;
  body: mixed;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareModule {
  type: 'DeclareModule';
  loc: ?Location;
  id: mixed;
  body: mixed;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareModuleExports {
  type: 'DeclareModuleExports';
  loc: ?Location;
  typeAnnotation: mixed;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareTypeAlias {
  type: 'DeclareTypeAlias';
  loc: ?Location;
  id: mixed;
  typeParameters: mixed;
  right: mixed;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareVariable {
  type: 'DeclareVariable';
  loc: ?Location;
  id: mixed;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class Decorator {
  type: 'Decorator';
  loc: ?Location;
  expression: Expression;

  // alias: BabelNode
}

declare class Directive {
  type: 'Directive';
  loc: ?Location;
  value: DirectiveLiteral;

  // alias: BabelNode
}

declare class DirectiveLiteral {
  type: 'DirectiveLiteral';
  loc: ?Location;
  value: string;

  // alias: BabelNode
}

declare class DoExpression {
  type: 'DoExpression';
  loc: ?Location;
  body: BlockStatement;

  // alias: Expression
  // alias: BabelNode
}

declare class DoWhileStatement {
  type: 'DoWhileStatement';
  loc: ?Location;
  test: Expression;
  body: Statement;

  // alias: Statement
  // alias: BlockParent
  // alias: Loop
  // alias: While
  // alias: Scopable
  // alias: BabelNode
}

declare class EmptyStatement {
  type: 'EmptyStatement';
  loc: ?Location;

  // alias: Statement
  // alias: BabelNode
}

declare class EmptyTypeAnnotation {
  type: 'EmptyTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class ExistentialTypeParam {
  type: 'ExistentialTypeParam';
  loc: ?Location;

  // alias: Flow
  // alias: BabelNode
}

declare class ExportAllDeclaration {
  type: 'ExportAllDeclaration';
  loc: ?Location;
  source: StringLiteral;

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: ExportDeclaration
  // alias: BabelNode
}

declare class ExportDefaultDeclaration {
  type: 'ExportDefaultDeclaration';
  loc: ?Location;
  declaration: FunctionDeclaration | ClassDeclaration | Expression;

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: ExportDeclaration
  // alias: BabelNode
}

declare class ExportDefaultSpecifier {
  type: 'ExportDefaultSpecifier';
  loc: ?Location;
  exported: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ExportNamedDeclaration {
  type: 'ExportNamedDeclaration';
  loc: ?Location;
  declaration: ?Declaration;
  specifiers: $ReadOnlyArray<ExportSpecifier>;
  source: ?StringLiteral;

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: ExportDeclaration
  // alias: BabelNode
}

declare class ExportNamespaceSpecifier {
  type: 'ExportNamespaceSpecifier';
  loc: ?Location;
  exported: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ExportSpecifier {
  type: 'ExportSpecifier';
  loc: ?Location;
  local: Identifier;
  exported: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ExpressionStatement {
  type: 'ExpressionStatement';
  loc: ?Location;
  expression: Expression;

  // alias: Statement
  // alias: ExpressionWrapper
  // alias: BabelNode
}

declare class File {
  type: 'File';
  loc: ?Location;
  program: Program;
  comments: mixed;
  tokens: mixed;

  // alias: BabelNode
}

declare class ForAwaitStatement {
  type: 'ForAwaitStatement';
  loc: ?Location;
  left: VariableDeclaration | LVal;
  right: Expression;
  body: Statement;

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: ForXStatement
  // alias: BabelNode
}

declare class ForInStatement {
  type: 'ForInStatement';
  loc: ?Location;
  left: VariableDeclaration | LVal;
  right: Expression;
  body: Statement;

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: ForXStatement
  // alias: BabelNode
}

declare class ForOfStatement {
  type: 'ForOfStatement';
  loc: ?Location;
  left: VariableDeclaration | LVal;
  right: Expression;
  body: Statement;

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: ForXStatement
  // alias: BabelNode
}

declare class ForStatement {
  type: 'ForStatement';
  loc: ?Location;
  init: ?VariableDeclaration | Expression;
  test: ?Expression;
  update: ?Expression;
  body: Statement;

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: BabelNode
}

declare class FunctionDeclaration {
  type: 'FunctionDeclaration';
  loc: ?Location;
  id: Identifier;
  params: $ReadOnlyArray<LVal>;
  body: BlockStatement;
  generator: boolean;
  async: boolean;
  returnType: ?mixed;
  typeParameters: ?mixed;

  // alias: Scopable
  // alias: Function
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Statement
  // alias: Pureish
  // alias: Declaration
  // alias: BabelNode
}

declare class FunctionExpression {
  type: 'FunctionExpression';
  loc: ?Location;
  id: ?Identifier;
  params: $ReadOnlyArray<LVal>;
  body: BlockStatement;
  generator: boolean;
  async: boolean;
  returnType: ?mixed;
  typeParameters: ?mixed;

  // alias: Scopable
  // alias: Function
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Expression
  // alias: Pureish
  // alias: BabelNode
}

declare class FunctionTypeAnnotation {
  type: 'FunctionTypeAnnotation';
  loc: ?Location;
  typeParameters: mixed;
  params: mixed;
  rest: mixed;
  returnType: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class FunctionTypeParam {
  type: 'FunctionTypeParam';
  loc: ?Location;
  name: mixed;
  typeAnnotation: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class GenericTypeAnnotation {
  type: 'GenericTypeAnnotation';
  loc: ?Location;
  id: mixed;
  typeParameters: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class Identifier {
  type: 'Identifier';
  loc: ?Location;
  name: string;
  decorators: ?$ReadOnlyArray<Decorator>;
  typeAnnotation: ?mixed;

  // alias: Expression
  // alias: LVal
  // alias: BabelNode
}

declare class IfStatement {
  type: 'IfStatement';
  loc: ?Location;
  test: Expression;
  consequent: Statement;
  alternate: ?Statement;

  // alias: Statement
  // alias: Conditional
  // alias: BabelNode
}

declare class Import {
  type: 'Import';
  loc: ?Location;

  // alias: Expression
  // alias: BabelNode
}

declare class ImportDeclaration {
  type: 'ImportDeclaration';
  loc: ?Location;
  specifiers: $ReadOnlyArray<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>;
  source: StringLiteral;

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: BabelNode
}

declare class ImportDefaultSpecifier {
  type: 'ImportDefaultSpecifier';
  loc: ?Location;
  local: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ImportNamespaceSpecifier {
  type: 'ImportNamespaceSpecifier';
  loc: ?Location;
  local: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ImportSpecifier {
  type: 'ImportSpecifier';
  loc: ?Location;
  local: Identifier;
  imported: Identifier;
  importKind: ?null | 'type' | 'typeof';

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class InterfaceDeclaration {
  type: 'InterfaceDeclaration';
  loc: ?Location;
  id: mixed;
  typeParameters: mixed;
  extends: mixed;
  body: mixed;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class InterfaceExtends {
  type: 'InterfaceExtends';
  loc: ?Location;
  id: mixed;
  typeParameters: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class IntersectionTypeAnnotation {
  type: 'IntersectionTypeAnnotation';
  loc: ?Location;
  types: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class JSXAttribute {
  type: 'JSXAttribute';
  loc: ?Location;
  name: JSXIdentifier | JSXNamespacedName;
  value: ?JSXElement | StringLiteral | JSXExpressionContainer;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXClosingElement {
  type: 'JSXClosingElement';
  loc: ?Location;
  name: JSXIdentifier | JSXMemberExpression;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXElement {
  type: 'JSXElement';
  loc: ?Location;
  openingElement: JSXOpeningElement;
  closingElement: ?JSXClosingElement;
  children: $ReadOnlyArray<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement>;
  selfClosing: mixed;

  // alias: JSX
  // alias: Immutable
  // alias: Expression
  // alias: BabelNode
}

declare class JSXEmptyExpression {
  type: 'JSXEmptyExpression';
  loc: ?Location;

  // alias: JSX
  // alias: Expression
  // alias: BabelNode
}

declare class JSXExpressionContainer {
  type: 'JSXExpressionContainer';
  loc: ?Location;
  expression: Expression;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXIdentifier {
  type: 'JSXIdentifier';
  loc: ?Location;
  name: string;

  // alias: JSX
  // alias: Expression
  // alias: BabelNode
}

declare class JSXMemberExpression {
  type: 'JSXMemberExpression';
  loc: ?Location;
  object: JSXMemberExpression | JSXIdentifier;
  property: JSXIdentifier;

  // alias: JSX
  // alias: Expression
  // alias: BabelNode
}

declare class JSXNamespacedName {
  type: 'JSXNamespacedName';
  loc: ?Location;
  namespace: JSXIdentifier;
  name: JSXIdentifier;

  // alias: JSX
  // alias: BabelNode
}

declare class JSXOpeningElement {
  type: 'JSXOpeningElement';
  loc: ?Location;
  name: JSXIdentifier | JSXMemberExpression;
  attributes: $ReadOnlyArray<JSXAttribute | JSXSpreadAttribute>;
  selfClosing: boolean;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXSpreadAttribute {
  type: 'JSXSpreadAttribute';
  loc: ?Location;
  argument: Expression;

  // alias: JSX
  // alias: BabelNode
}

declare class JSXSpreadChild {
  type: 'JSXSpreadChild';
  loc: ?Location;
  expression: Expression;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXText {
  type: 'JSXText';
  loc: ?Location;
  value: string;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class LabeledStatement {
  type: 'LabeledStatement';
  loc: ?Location;
  label: Identifier;
  body: Statement;

  // alias: Statement
  // alias: BabelNode
}

declare class LogicalExpression {
  type: 'LogicalExpression';
  loc: ?Location;
  operator: '||' | '&&';
  left: Expression;
  right: Expression;

  // alias: Binary
  // alias: Expression
  // alias: BabelNode
}

declare class MemberExpression {
  type: 'MemberExpression';
  loc: ?Location;
  object: Expression;
  property: Expression;
  computed: boolean;

  // alias: Expression
  // alias: LVal
  // alias: BabelNode
}

declare class MetaProperty {
  type: 'MetaProperty';
  loc: ?Location;
  meta: string;
  property: string;

  // alias: Expression
  // alias: BabelNode
}

declare class MixedTypeAnnotation {
  type: 'MixedTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class NewExpression {
  type: 'NewExpression';
  loc: ?Location;
  callee: Expression;
  arguments: $ReadOnlyArray<Expression | SpreadElement>;

  // alias: Expression
  // alias: BabelNode
}

declare class Noop {
  type: 'Noop';
  loc: ?Location;

  // alias: BabelNode
}

declare class NullLiteral {
  type: 'NullLiteral';
  loc: ?Location;

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: BabelNode
}

declare class NullLiteralTypeAnnotation {
  type: 'NullLiteralTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class NullableTypeAnnotation {
  type: 'NullableTypeAnnotation';
  loc: ?Location;
  typeAnnotation: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class NumberTypeAnnotation {
  type: 'NumberTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class NumericLiteral {
  type: 'NumericLiteral';
  loc: ?Location;
  value: number;

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: BabelNode
}

declare class NumericLiteralTypeAnnotation {
  type: 'NumericLiteralTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: BabelNode
}

declare class ObjectExpression {
  type: 'ObjectExpression';
  loc: ?Location;
  properties: $ReadOnlyArray<ObjectMethod | ObjectProperty | SpreadProperty>;

  // alias: Expression
  // alias: BabelNode
}

declare class ObjectMethod {
  type: 'ObjectMethod';
  loc: ?Location;
  kind: "method" | "get" | "set";
  key: Expression;
  params: mixed;
  body: BlockStatement;
  computed: boolean;
  async: ?boolean;
  decorators: ?$ReadOnlyArray<Decorator>;
  generator: ?boolean;
  returnType: ?mixed;
  typeParameters: ?mixed;

  // alias: UserWhitespacable
  // alias: Function
  // alias: Scopable
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Method
  // alias: ObjectMember
  // alias: BabelNode
}

declare class ObjectPattern {
  type: 'ObjectPattern';
  loc: ?Location;
  properties: $ReadOnlyArray<RestProperty | Property>;
  typeAnnotation: mixed;
  decorators: ?$ReadOnlyArray<Decorator>;

  // alias: Pattern
  // alias: LVal
  // alias: BabelNode
}

declare class ObjectProperty {
  type: 'ObjectProperty';
  loc: ?Location;
  key: Expression;
  value: Expression;
  computed: boolean;
  shorthand: boolean;
  decorators: ?$ReadOnlyArray<Decorator>;

  // alias: UserWhitespacable
  // alias: Property
  // alias: ObjectMember
  // alias: BabelNode
}

declare class ObjectTypeAnnotation {
  type: 'ObjectTypeAnnotation';
  loc: ?Location;
  properties: mixed;
  indexers: mixed;
  callProperties: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class ObjectTypeCallProperty {
  type: 'ObjectTypeCallProperty';
  loc: ?Location;
  value: mixed;

  // alias: Flow
  // alias: UserWhitespacable
  // alias: BabelNode
}

declare class ObjectTypeIndexer {
  type: 'ObjectTypeIndexer';
  loc: ?Location;
  id: mixed;
  key: mixed;
  value: mixed;

  // alias: Flow
  // alias: UserWhitespacable
  // alias: BabelNode
}

declare class ObjectTypeProperty {
  type: 'ObjectTypeProperty';
  loc: ?Location;
  key: mixed;
  value: mixed;

  // alias: Flow
  // alias: UserWhitespacable
  // alias: BabelNode
}

declare class ParenthesizedExpression {
  type: 'ParenthesizedExpression';
  loc: ?Location;
  expression: Expression;

  // alias: Expression
  // alias: ExpressionWrapper
  // alias: BabelNode
}

declare class Program {
  type: 'Program';
  loc: ?Location;
  body: $ReadOnlyArray<Statement>;
  directives: $ReadOnlyArray<Directive>;

  // alias: Scopable
  // alias: BlockParent
  // alias: Block
  // alias: FunctionParent
  // alias: BabelNode
}

declare class QualifiedTypeIdentifier {
  type: 'QualifiedTypeIdentifier';
  loc: ?Location;
  id: mixed;
  qualification: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class RegExpLiteral {
  type: 'RegExpLiteral';
  loc: ?Location;
  pattern: string;
  flags: string;

  // alias: Expression
  // alias: Literal
  // alias: BabelNode
}

declare class RestElement {
  type: 'RestElement';
  loc: ?Location;
  argument: LVal;
  typeAnnotation: mixed;
  decorators: ?$ReadOnlyArray<Decorator>;

  // alias: LVal
  // alias: BabelNode
}

declare class RestProperty {
  type: 'RestProperty';
  loc: ?Location;
  argument: LVal;

  // alias: UnaryLike
  // alias: BabelNode
}

declare class ReturnStatement {
  type: 'ReturnStatement';
  loc: ?Location;
  argument: ?Expression;

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: BabelNode
}

declare class SequenceExpression {
  type: 'SequenceExpression';
  loc: ?Location;
  expressions: $ReadOnlyArray<Expression>;

  // alias: Expression
  // alias: BabelNode
}

declare class SpreadElement {
  type: 'SpreadElement';
  loc: ?Location;
  argument: Expression;

  // alias: UnaryLike
  // alias: BabelNode
}

declare class SpreadProperty {
  type: 'SpreadProperty';
  loc: ?Location;
  argument: Expression;

  // alias: UnaryLike
  // alias: BabelNode
}

declare class StringLiteral {
  type: 'StringLiteral';
  loc: ?Location;
  value: string;

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: BabelNode
}

declare class StringLiteralTypeAnnotation {
  type: 'StringLiteralTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: BabelNode
}

declare class StringTypeAnnotation {
  type: 'StringTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class Super {
  type: 'Super';
  loc: ?Location;

  // alias: Expression
  // alias: BabelNode
}

declare class SwitchCase {
  type: 'SwitchCase';
  loc: ?Location;
  test: ?Expression;
  consequent: $ReadOnlyArray<Statement>;

  // alias: BabelNode
}

declare class SwitchStatement {
  type: 'SwitchStatement';
  loc: ?Location;
  discriminant: Expression;
  cases: $ReadOnlyArray<SwitchCase>;

  // alias: Statement
  // alias: BlockParent
  // alias: Scopable
  // alias: BabelNode
}

declare class TaggedTemplateExpression {
  type: 'TaggedTemplateExpression';
  loc: ?Location;
  tag: Expression;
  quasi: TemplateLiteral;

  // alias: Expression
  // alias: BabelNode
}

declare class TemplateElement {
  type: 'TemplateElement';
  loc: ?Location;
  value: mixed;
  tail: boolean;

  // alias: BabelNode
}

declare class TemplateLiteral {
  type: 'TemplateLiteral';
  loc: ?Location;
  quasis: $ReadOnlyArray<TemplateElement>;
  expressions: $ReadOnlyArray<Expression>;

  // alias: Expression
  // alias: Literal
  // alias: BabelNode
}

declare class ThisExpression {
  type: 'ThisExpression';
  loc: ?Location;

  // alias: Expression
  // alias: BabelNode
}

declare class ThisTypeAnnotation {
  type: 'ThisTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class ThrowStatement {
  type: 'ThrowStatement';
  loc: ?Location;
  argument: Expression;

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: BabelNode
}

declare class TryStatement {
  type: 'TryStatement';
  loc: ?Location;
  block: mixed;
  handler: ?mixed;
  finalizer: ?BlockStatement;
  body: ?BlockStatement;

  // alias: Statement
  // alias: BabelNode
}

declare class TupleTypeAnnotation {
  type: 'TupleTypeAnnotation';
  loc: ?Location;
  types: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class TypeAlias {
  type: 'TypeAlias';
  loc: ?Location;
  id: mixed;
  typeParameters: mixed;
  right: mixed;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class TypeAnnotation {
  type: 'TypeAnnotation';
  loc: ?Location;
  typeAnnotation: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class TypeCastExpression {
  type: 'TypeCastExpression';
  loc: ?Location;
  expression: mixed;
  typeAnnotation: mixed;

  // alias: Flow
  // alias: ExpressionWrapper
  // alias: Expression
  // alias: BabelNode
}

declare class TypeParameter {
  type: 'TypeParameter';
  loc: ?Location;
  bound: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class TypeParameterDeclaration {
  type: 'TypeParameterDeclaration';
  loc: ?Location;
  params: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class TypeParameterInstantiation {
  type: 'TypeParameterInstantiation';
  loc: ?Location;
  params: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class TypeofTypeAnnotation {
  type: 'TypeofTypeAnnotation';
  loc: ?Location;
  argument: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class UnaryExpression {
  type: 'UnaryExpression';
  loc: ?Location;
  operator: 'void' | 'delete' | '!' | '+' | '-' | '++' | '--' | '~' | 'typeof';
  argument: Expression;
  prefix: boolean;

  // alias: UnaryLike
  // alias: Expression
  // alias: BabelNode
}

declare class UnionTypeAnnotation {
  type: 'UnionTypeAnnotation';
  loc: ?Location;
  types: mixed;

  // alias: Flow
  // alias: BabelNode
}

declare class UpdateExpression {
  type: 'UpdateExpression';
  loc: ?Location;
  operator: '++' | '--';
  argument: Expression;
  prefix: boolean;

  // alias: Expression
  // alias: BabelNode
}

declare class VariableDeclaration {
  type: 'VariableDeclaration';
  loc: ?Location;
  kind: "var" | "let" | "const";
  declarations: $ReadOnlyArray<VariableDeclarator>;

  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class VariableDeclarator {
  type: 'VariableDeclarator';
  loc: ?Location;
  id: LVal;
  init: ?Expression;

  // alias: BabelNode
}

declare class VoidTypeAnnotation {
  type: 'VoidTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class WhileStatement {
  type: 'WhileStatement';
  loc: ?Location;
  test: Expression;
  body: BlockStatement | Statement;

  // alias: Statement
  // alias: BlockParent
  // alias: Loop
  // alias: While
  // alias: Scopable
  // alias: BabelNode
}

declare class WithStatement {
  type: 'WithStatement';
  loc: ?Location;
  object: mixed;
  body: BlockStatement | Statement;

  // alias: Statement
  // alias: BabelNode
}

declare class YieldExpression {
  type: 'YieldExpression';
  loc: ?Location;
  argument: ?Expression;
  delegate: boolean;

  // alias: Expression
  // alias: Terminatorless
  // alias: BabelNode
}

type Flow = (
  | AnyTypeAnnotation
  | ArrayTypeAnnotation
  | BooleanLiteralTypeAnnotation
  | BooleanTypeAnnotation
  | ClassImplements
  | DeclareClass
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareTypeAlias
  | DeclareVariable
  | EmptyTypeAnnotation
  | ExistentialTypeParam
  | FunctionTypeAnnotation
  | FunctionTypeParam
  | GenericTypeAnnotation
  | InterfaceDeclaration
  | InterfaceExtends
  | IntersectionTypeAnnotation
  | MixedTypeAnnotation
  | NullLiteralTypeAnnotation
  | NullableTypeAnnotation
  | NumberTypeAnnotation
  | NumericLiteralTypeAnnotation
  | ObjectTypeAnnotation
  | ObjectTypeCallProperty
  | ObjectTypeIndexer
  | ObjectTypeProperty
  | QualifiedTypeIdentifier
  | StringLiteralTypeAnnotation
  | StringTypeAnnotation
  | ThisTypeAnnotation
  | TupleTypeAnnotation
  | TypeAlias
  | TypeAnnotation
  | TypeCastExpression
  | TypeParameter
  | TypeParameterDeclaration
  | TypeParameterInstantiation
  | TypeofTypeAnnotation
  | UnionTypeAnnotation
  | VoidTypeAnnotation
);

type FlowBaseAnnotation = (
  | AnyTypeAnnotation
  | BooleanTypeAnnotation
  | EmptyTypeAnnotation
  | MixedTypeAnnotation
  | NullLiteralTypeAnnotation
  | NumberTypeAnnotation
  | StringTypeAnnotation
  | ThisTypeAnnotation
  | VoidTypeAnnotation
);

type BabelNode = (
  | AnyTypeAnnotation
  | ArrayExpression
  | ArrayPattern
  | ArrayTypeAnnotation
  | ArrowFunctionExpression
  | AssignmentExpression
  | AssignmentPattern
  | AwaitExpression
  | BinaryExpression
  | BindExpression
  | BlockStatement
  | BooleanLiteral
  | BooleanLiteralTypeAnnotation
  | BooleanTypeAnnotation
  | BreakStatement
  | CallExpression
  | CatchClause
  | ClassBody
  | ClassDeclaration
  | ClassExpression
  | ClassImplements
  | ClassMethod
  | ClassProperty
  | ConditionalExpression
  | ContinueStatement
  | DebuggerStatement
  | DeclareClass
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareTypeAlias
  | DeclareVariable
  | Decorator
  | Directive
  | DirectiveLiteral
  | DoExpression
  | DoWhileStatement
  | EmptyStatement
  | EmptyTypeAnnotation
  | ExistentialTypeParam
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportDefaultSpecifier
  | ExportNamedDeclaration
  | ExportNamespaceSpecifier
  | ExportSpecifier
  | ExpressionStatement
  | File
  | ForAwaitStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | FunctionTypeAnnotation
  | FunctionTypeParam
  | GenericTypeAnnotation
  | Identifier
  | IfStatement
  | Import
  | ImportDeclaration
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ImportSpecifier
  | InterfaceDeclaration
  | InterfaceExtends
  | IntersectionTypeAnnotation
  | JSXAttribute
  | JSXClosingElement
  | JSXElement
  | JSXEmptyExpression
  | JSXExpressionContainer
  | JSXIdentifier
  | JSXMemberExpression
  | JSXNamespacedName
  | JSXOpeningElement
  | JSXSpreadAttribute
  | JSXSpreadChild
  | JSXText
  | LabeledStatement
  | LogicalExpression
  | MemberExpression
  | MetaProperty
  | MixedTypeAnnotation
  | NewExpression
  | Noop
  | NullLiteral
  | NullLiteralTypeAnnotation
  | NullableTypeAnnotation
  | NumberTypeAnnotation
  | NumericLiteral
  | NumericLiteralTypeAnnotation
  | ObjectExpression
  | ObjectMethod
  | ObjectPattern
  | ObjectProperty
  | ObjectTypeAnnotation
  | ObjectTypeCallProperty
  | ObjectTypeIndexer
  | ObjectTypeProperty
  | ParenthesizedExpression
  | Program
  | QualifiedTypeIdentifier
  | RegExpLiteral
  | RestElement
  | RestProperty
  | ReturnStatement
  | SequenceExpression
  | SpreadElement
  | SpreadProperty
  | StringLiteral
  | StringLiteralTypeAnnotation
  | StringTypeAnnotation
  | Super
  | SwitchCase
  | SwitchStatement
  | TaggedTemplateExpression
  | TemplateElement
  | TemplateLiteral
  | ThisExpression
  | ThisTypeAnnotation
  | ThrowStatement
  | TryStatement
  | TupleTypeAnnotation
  | TypeAlias
  | TypeAnnotation
  | TypeCastExpression
  | TypeParameter
  | TypeParameterDeclaration
  | TypeParameterInstantiation
  | TypeofTypeAnnotation
  | UnaryExpression
  | UnionTypeAnnotation
  | UpdateExpression
  | VariableDeclaration
  | VariableDeclarator
  | VoidTypeAnnotation
  | WhileStatement
  | WithStatement
  | YieldExpression
);

type Expression = (
  | ArrayExpression
  | ArrowFunctionExpression
  | AssignmentExpression
  | AwaitExpression
  | BinaryExpression
  | BindExpression
  | BooleanLiteral
  | CallExpression
  | ClassExpression
  | ConditionalExpression
  | DoExpression
  | FunctionExpression
  | Identifier
  | Import
  | JSXElement
  | JSXEmptyExpression
  | JSXIdentifier
  | JSXMemberExpression
  | LogicalExpression
  | MemberExpression
  | MetaProperty
  | NewExpression
  | NullLiteral
  | NumericLiteral
  | ObjectExpression
  | ParenthesizedExpression
  | RegExpLiteral
  | SequenceExpression
  | StringLiteral
  | Super
  | TaggedTemplateExpression
  | TemplateLiteral
  | ThisExpression
  | TypeCastExpression
  | UnaryExpression
  | UpdateExpression
  | YieldExpression
);

type Pattern = (
  | ArrayPattern
  | AssignmentPattern
  | ObjectPattern
);

type LVal = (
  | ArrayPattern
  | AssignmentPattern
  | Identifier
  | MemberExpression
  | ObjectPattern
  | RestElement
);

type Scopable = (
  | ArrowFunctionExpression
  | BlockStatement
  | CatchClause
  | ClassDeclaration
  | ClassExpression
  | ClassMethod
  | DoWhileStatement
  | ForAwaitStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
  | Program
  | SwitchStatement
  | WhileStatement
);

type Function = (
  | ArrowFunctionExpression
  | ClassMethod
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
);

type BlockParent = (
  | ArrowFunctionExpression
  | BlockStatement
  | ClassMethod
  | DoWhileStatement
  | ForAwaitStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
  | Program
  | SwitchStatement
  | WhileStatement
);

type FunctionParent = (
  | ArrowFunctionExpression
  | ClassMethod
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
  | Program
);

type Pureish = (
  | ArrowFunctionExpression
  | BooleanLiteral
  | ClassDeclaration
  | ClassExpression
  | FunctionDeclaration
  | FunctionExpression
  | NullLiteral
  | NumericLiteral
  | StringLiteral
);

type Terminatorless = (
  | AwaitExpression
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
  | ThrowStatement
  | YieldExpression
);

type Binary = (
  | BinaryExpression
  | LogicalExpression
);

type Block = (
  | BlockStatement
  | Program
);

type Statement = (
  | BlockStatement
  | BreakStatement
  | ClassDeclaration
  | ContinueStatement
  | DebuggerStatement
  | DeclareClass
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareTypeAlias
  | DeclareVariable
  | DoWhileStatement
  | EmptyStatement
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ExpressionStatement
  | ForAwaitStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | FunctionDeclaration
  | IfStatement
  | ImportDeclaration
  | InterfaceDeclaration
  | LabeledStatement
  | ReturnStatement
  | SwitchStatement
  | ThrowStatement
  | TryStatement
  | TypeAlias
  | VariableDeclaration
  | WhileStatement
  | WithStatement
);

type Literal = (
  | BooleanLiteral
  | NullLiteral
  | NumericLiteral
  | RegExpLiteral
  | StringLiteral
  | TemplateLiteral
);

type Immutable = (
  | BooleanLiteral
  | JSXAttribute
  | JSXClosingElement
  | JSXElement
  | JSXExpressionContainer
  | JSXOpeningElement
  | JSXSpreadChild
  | JSXText
  | NullLiteral
  | NumericLiteral
  | StringLiteral
);

type CompletionStatement = (
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
  | ThrowStatement
);

type Class = (
  | ClassDeclaration
  | ClassExpression
);

type Declaration = (
  | ClassDeclaration
  | DeclareClass
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareTypeAlias
  | DeclareVariable
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | FunctionDeclaration
  | ImportDeclaration
  | InterfaceDeclaration
  | TypeAlias
  | VariableDeclaration
);

type Method = (
  | ClassMethod
  | ObjectMethod
);

type Property = (
  | ClassProperty
  | ObjectProperty
);

type Conditional = (
  | ConditionalExpression
  | IfStatement
);

type FlowDeclaration = (
  | DeclareClass
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareTypeAlias
  | DeclareVariable
  | InterfaceDeclaration
  | TypeAlias
);

type Loop = (
  | DoWhileStatement
  | ForAwaitStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | WhileStatement
);

type While = (
  | DoWhileStatement
  | WhileStatement
);

type ModuleDeclaration = (
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ImportDeclaration
);

type ExportDeclaration = (
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
);

type ModuleSpecifier = (
  | ExportDefaultSpecifier
  | ExportNamespaceSpecifier
  | ExportSpecifier
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ImportSpecifier
);

type ExpressionWrapper = (
  | ExpressionStatement
  | ParenthesizedExpression
  | TypeCastExpression
);

type For = (
  | ForAwaitStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
);

type ForXStatement = (
  | ForAwaitStatement
  | ForInStatement
  | ForOfStatement
);

type JSX = (
  | JSXAttribute
  | JSXClosingElement
  | JSXElement
  | JSXEmptyExpression
  | JSXExpressionContainer
  | JSXIdentifier
  | JSXMemberExpression
  | JSXNamespacedName
  | JSXOpeningElement
  | JSXSpreadAttribute
  | JSXSpreadChild
  | JSXText
);

type UserWhitespacable = (
  | ObjectMethod
  | ObjectProperty
  | ObjectTypeCallProperty
  | ObjectTypeIndexer
  | ObjectTypeProperty
);

type ObjectMember = (
  | ObjectMethod
  | ObjectProperty
);

type UnaryLike = (
  | RestProperty
  | SpreadElement
  | SpreadProperty
  | UnaryExpression
);

type JSXValue = JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement;